extends ../layout

block append vars
  page_id = 'doc'
  path_prefix = '../'

block append title
  | - Documentation

block content
  h1 Table of Contents
  nav.toc
    ul
      li: a(href='language.html') Language Specification
        ul
          li: a(href='language.html#by-type') Symbols by Type
            ul
              li: a(href='language.html#constants') Constants
              li: a(href='language.html#unary') Unary Operators
              li: a(href='language.html#binary') Binary Operators
              li: a(href='language.html#relations') Relations
              li: a(href='language.html#delimiters') Delimiters
              li: a(href='language.html#functions') Functions
          li: a(href='language.html#by-subject') Symbols by Subject
      li: a(href='building.html') Building from Source
      li Appendices
        ol(type='A')
          li: a(href='tokens.html') List of Tokens
          li: a(href='tree-nodes.html') List of Syntax Nodes

  h1#how-mathlex-works How MathLex Works

  p.
    When provided with a valid MathLex string, <code>MathParser.parse()</code> produces an <em>abstract
    syntax tree (AST)</em> representing the explicit, inferred value of the MathLex code. This representative
    tree is built from different "node" types represented as a recursive array. Every node has at
    least one element (i.e. the 0<sup>th</sup> element or <code>node[0]</code> in JS) that is a
    string indicator of the type of node. <a href="tree-nodes.html">Appendix B</a> lists all possible
    nodes and their structure.

  p.
    Under the hood, MathLex has two components: a Tokenizer and a Parser. The <strong>Tokenizer</strong>
    is responsible for translating the characters in the MathLex input string into a list of <em>Tokens</em>,
    a way to group related characters into a single symbol. For example, "<code>&lt;=</code>"
    is shorthand for "less than or equal to" (in display math, '&le;') and is comprised of two separate
    characters. The Tokenizer groups these characters into a <code>TLessEqual</code> for the parser.

  p.
    The <strong>Parser</strong> then reads the list of tokens and assembles the corresponding abstract
    syntax tree (AST) based on the rules in <code>src/grammar.coffee</code>. The parser code
    itself is generated by <a href="http://zaach.github.com/jison" target="_blank">Jison</a> and
    for most purposes is unreadable.
