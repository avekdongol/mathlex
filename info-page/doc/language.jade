extends layout

block append vars
  next_page = {href: 'building.html', title: 'Build Instructions'}

block article

  section#language-specs
    h1 Language Specification

    p.
      This section describes the syntax used to enter mathematical content into MathLex. For
      clarity, this information is presented in two ways: the first is organized by how the symbol
      is used in the language (e.g. unary vs. binary operators); the second is organized by the
      topic which uses the symbol (e.g. calculus vs. set theory). This page is meant to be a
      non-technical reference for the end-user (i.e. student) typing MathLex input.


    h2 Section Contents
    nav.toc
      ul
        li: a(href='#by-type') Symbols by Type
          ul
            li: a(href='#constants') Constants
            li: a(href='#unary') Unary Operators
            li: a(href='#binary') Binary Operators
            li: a(href='#relations') Relations
            li: a(href='#delimiters') Delimiters
            li: a(href='#functions') Functions
        li: a(href='#by-topic') Symbols by Topic

  h2 Summary

  p.
    The basic types of tokens in MathLex are Numbers (further subdivided into Integers and
    Floats/Decimals), Identifiers, Constants, and Operators. Numbers are exactly as they seem:
    <code>42</code>, <code>3.14</code>, etc. Scientific notation is also allowed: <code>5e-2</code>
    <code>3.0E8</code>. In either case, decimal points do not need a leading or trailing zero:
    <code>.5</code>, <code>78.</code>, <code>9.E-4</code>, <code>.22e7</code>.  Note that negative
    numbers are treated as a negation operation on the positive value of the number (in continuity
    with algebraic notation).

  p.
    An <em>Identifier</em> is an upper- or lowercase letter followed by any number of upper- or
    lowercase letters, numbers, or underscores (<code>_</code>). All of the following are valid
    identifiers: <code>x</code>, <code>A</code>, <code>b0</code>, <code>my_var</code> Identifiers
    fall under two categories: reserved keywords and variables. Reserved keywords are listed in the
    tables below, and all other identifiers are treated as variables. Since none of the above
    identifiers are reserved keywords, they also qualify as valid variable names.

  p.
    Similar to identifiers, <em>Constants</em> are globally defined values or constructs. In
    MathLex, constants are typed as a number sign (<code>#</code>) followed by the name of the
    constant. For example, "pi" (\( \pi \)) is defined as the value 3.14159&hellip;. In MathLex, you
    would type <code>#pi</code> (or <code>#p</code> for short) to represent this constant. See the
    <a href="#constants">table of constants</a> below for a comprehensive list.

  p.
    <em>Operators</em> is just a catch-all term for any symbol that is not a Number, Identifier,
    or Constant. With the exception of a few reserved keywords, operators usually consist of a few
    non-alphanumeric characters. Some mathematical operators can be represented in many ways in
    MathLex. The tables below outline all mathematical operators understood by MathLex and all ways
    to represent them. Pick your favorite.

  section#by-type
    h2 Symbols by Type

    table#constants
      caption Constants
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Pi
          td \( \pi \)
          td: code #pi, #p
          td 3.142&hellip;
        tr
          td Tau
          td \( \tau \)
          td: code #tau, #t
          td \( 2 \pi \approx 6.283 \ldots \);
        tr
          td E
          td \( \mathrm{e} \)
          td: code #e
          td 2.718&hellip;, Natural Base, Euler-Napier number
        tr
          td gamma
          td \( \gamma \)
          td: code #gamma
          td 0.577&hellip;, Euler-Mascheroni constant
        tr
          td infinity
          td \( \infty \)
          td: code #infinity, infinity
          td \( \infty \approx \) <span class="error">#!ERROR: memory overflow</span>
        tr
          td Imaginary Unit
          td \( i \)
          td: code #i
          td \( \sqrt{-1} \)
        tr
          td True
          td \( \mathbf{T} \)
          td: code #T, #true, true
          td
        tr
          td False
          td \( \mathbf{F} \)
          td: code #F, #false, false
          td
        tr
          td Natural Numbers
          td \( \mathbb{N} \)
          td: code #N
          td
        tr
          td Integer Ring
          td \( \mathbb{Z} \)
          td: code #Z
          td
        tr
          td Rational Field
          td \( \mathbb{Q} \)
          td: code #Q
          td
        tr
          td Real Field
          td \( \mathbb{R} \)
          td: code #R
          td
        tr
          td Complex Field
          td \( \mathbb{C} \)
          td: code #C
          td
        tr
          td Quaternion Ring
          td \( \mathbb{H} \)
          td: code #H
          td Hamilton numbers
        tr
          td Octonian Algebra
          td \( \mathbb{O} \)
          td: code #O
          td Cayley numbers, Type "Oh"
        tr
          td Universal Set
          td \( \mathbb{U} \)
          td: code #U
          td
        tr
          td Empty Set
          td \( \emptyset \)
          td: code #empty, {}
          td
        tr
          td Zero Vector
          td \( \vec{0} \)
          td: code #v0
          td
        tr
          td \( x \) Unit Vector
          td \( \hat{\imath} \)
          td: code #ui, #vi
          td
        tr
          td \( y \) Unit Vector
          td \( \hat{\jmath} \)
          td: code #uj, #vj
          td
        tr
          td \( z \) Unit Vector
          td \( \hat{k} \)
          td: code #uk, #vk
          td
        tr
          td Zero Matrix
          td \( \mathbf{0} \)
          td: code #0
          td Type "zero"
        tr
          td Unit Matrix
          td \( \mathbf{I} \)
          td: code #1
          td Identity Matrix, Type "one"

    p.
      The values in the <em>Precedence</em> column of operator tables reflect which operations are more
      tightly bound (e.g. the "<abbr title="Parentheses, Exponents, Multiplication, Division, Addition,
      Subtraction">PEMDAS</abbr>" order of operations from grade school mathematics). Operators of higher
      precedence (greater numerical value) will be identified and grouped before operators with lower
      precedence (lesser numerical value). Operators of equal precedence will be grouped as they are found
      according to their associativity.

    p.
      <em>Associativity</em> describes how chained operations would be bound together.

    ul
      li.
        Left-associative operators will be grouped from left to right (like addition and subtraction):
        <code>a + b + c + d = ((a + b) + c) + d</code>
      li.
        Right-associative operators will be grouped from right to left (like exponents):
        <code>a ^ b ^ c ^ d = a ^ (b ^ (c ^ d))</code>
      li.
        Non-associative operators cannot be chained (like dot products and, in the case of MathLex,
        <a href="#relations">relations</a>): <code>a &. b &. c</code> doesn't make any sense since the
        result of a dot product is a scalar.


    table#unary
      caption Unary Operators
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
          th Precedence
      tbody
        tr
          td Positive
          td \( +a \)
          td: code +a
          td
          td.center 17
        tr
          td Negative
          td \( -a \)
          td: code -a
          td
          td.center 17
        tr
          td Positive/Negative
          td \( \pm a \)
          td: code &amp;pm a, +/-a
          td
          td.center 17
        tr
          td Negative/Positive
          td \( \mp a \)
          td: code &amp;mp a, -/+a
          td
          td.center 17
        tr
          td Square Root
          td \( \sqrt{a} \)
          td: code sqrt(a)
        tr
          td Factorial
          td \( n! \)
          td: code a!
          td
          td.center 21
        tr
          td Natural Exponential
          td \( \exp(a) \)
          td: code exp(a)
          td
          td
        tr
          td Natural Logarithm
          td \( \ln(a) \)
          td: code ln(a)
          td
          td
        tr
          td Not
          td \( \neg p \)
          td: code not p, ~p, !p
          td Logical Negation
          td.center 17
        tr
          td Prime derivative
          td \( f' \)
          td: code f'
          td Derivative w.r.t. \( x \) or first or only variable
          td.center 21
        tr
          td Dot derivative
          td \( \dot{f} \)
          td: code f.
          td Derivative w.r.t. \( t \) or second variable
          td.center 21
        tr
          td Change
          td \( \Delta x \)
          td: code &amp;D x
          td Coordinate Difference
          td.center 17
        tr
          td Differential
          td \( \mathrm{d} x \)
          td: code &amp;d x
          td
          td.center 17
        tr
          td Partial Differential
          td \( \partial x \)
          td: code &amp;pd x
          td
          td.center 17
        tr
          td Vector
          td \( \vec{a} \)
          td: code &amp;v a
          td
          td.center 17
        tr
          td Unit Vector
          td \( \hat{a} \)
          td: code &amp;u a
          td
          td.center 17
        tr
          td Gradient
          td \( \vec{\nabla} f \), \( \mathrm{grad}(f) \)
          td: code &amp;del f, grad(f)
          td
          td.center 17
        tr
          td Divergence
          td \( \vec{\nabla} \cdot F \), \( \mathrm{div}(F) \)
          td: code &amp;del. F, div(F)
          td
          td.center 17
        tr
          td Curl
          td \( \vec{\nabla} \times F \), \( \mathrm{curl}(F) \)
          td: code &amp;delx F, curl(F)
          td
          td.center 17

    p.
      Although not listed, the left parenthesis, when used as a suffix in function application, may be
      considered a unary operator. MathLex treats function application as <strong>left-associative</strong>
      and a precedence of <strong>18</strong>, just below that of function composition and exponents.

    p.
      On a similar note, notice that all prefix operators are <strong>right-associative</strong> and
      all postfix operators are <strong>left-associative</strong>.

    table#binary
      caption Binary Operators
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
          th Precedence
          th Associativity
      tbody
        tr
          td Plus
          td \( a + b \)
          td: code a + b
          td Addition
          td.center 9
          td.center Left
        tr
          td Minus
          td \( a - b \)
          td: code a - b
          td Subtraction
          td.center 9
          td.center Left
        tr
          td Plus/Minus
          td \( a \pm b \)
          td: code a &amp;pm b, a +/- b
          td
          td.center 9
          td.center Left
        tr
          td Minus/Plus
          td \( a \mp b \)
          td: code a &amp;mp b, a -/+ b
          td
          td.center 9
          td.center Left
        tr
          td Times
          td \( a \cdot b \)
          td: code a * b
          td Multiplication
          td.center 14
          td.center Left
        tr
          td Divided by
          td \( \frac{a}{b} \), \( a/b \)
          td: code a/b, a &amp;/ b
          td Division
          td.center 14
          td.center Left
        tr
          td Power
          td \( a^b \)
          td: code a^b, a**b
          td Exponentiation
          td.center 20
          td.center Right
        tr
          td \( n \)-th Root
          td \( \sqrt[n]{a} \)
          td: code root(a, n)
          td
          td
          td
        tr
          td Logarithm with Base
          td \( \log_b{a} \)
          td: code log(a, b)
          td
          td
          td
        tr
          td Ratio
          td \( p :: q \)
          td: code p::q
          td
          td.center 8
          td.center Non
        tr
          td Modulus
          td \( a \pmod{n} \)
          td: code a%n, a mod n
          td
          td.center 14
          td.center Left
        tr
          td Combination
          td \( \binom{n}{r} \)
          td: code C(n,r)
          td
          td
          td
        tr
          td Permutation
          td \( P(n,r) \)
          td: code P(n,r)
          td
          td
          td
        tr
          td Subscript
          td \( a_b \)
          td: code a&amp;_b
          td(rowspan=2) Indexing
          td.center(rowspan=2) 22
          td.center(rowspan=2) Left
        tr
          td Multiple Subscript
          td \( a_{i,j,k} \)
          td: code a &amp;_ [i,j,k]
        tr
          td Superscript
          td \( a^b \)
          td: code a&amp;^b
          td(rowspan=2) Indexing
          td.center(rowspan=2) 22
          td.center(rowspan=2) Left
        tr
          td Multiple Superscript
          td \( a^{i,j,k} \)
          td: code a &amp;^ [i,j,k]
        tr
          td Mixed Subscripts and Superscripts
          td \( T{}^i{}_j{}}^k \)
          td
          td
          td
          td
        tr
          td Union
          td \( a \cup b \)
          td: code a union b
          td
          td.center 12
          td.center Left
        tr
          td Intersection
          td \( a \cap b \)
          td: code a intersect b
          td
          td.center 13
          td.center Left
        tr
          td Set Difference
          td \( a \setminus b \)
          td: code a \ b
          td
          td.center 10
          td.center Left
        tr
          td Such That
          td \( p : q \)
          td: code p:q
          td Used with set builder and quantifiers
          td
          td
        tr
          td And
          td \( p \wedge q \)
          td: code p and q, p &amp;&amp; q
          td Conjugation
          td.center 5
          td.center Left
        tr
          td Or
          td \( p \vee q \)
          td: code p or q, p || q
          td Disjunction
          td.center 3
          td.center Left
        tr
          td Exclusive Or
          td \( p \veebar q \)
          td: code p xor q
          td Exclusion
          td.center 4
          td.center Left
        tr
          td Implies
          td \( p \rightarrow q \)
          td: code p -> q, p implies q, p onlyif q, if p then q
          td Conditional
          td.center 2
          td.center Left
        tr
          td Implied By
          td \( p \leftarrow q \)
          td: code p <- q, p imqliedby q, p if q, p when q, p whenever q
          td Reverse Conditional
          td.center 2
          td.center Left
        tr
          td If And Only If
          td \( p \leftrightarrow q \)
          td: code p <-> q, p iff q
          td Biconditional
          td.center 1
          td.center Non
        tr
          td Function Composition
          td \( f \circ g \)
          td: code f @ g
          td
          td.center 19
          td.center Left
        tr
          td Function Repeated Composition
          td \( f^{\circ n} \)
          td: code f @@ n
          td(colspan=3) (Not implemented)
        tr
          td Dot Product
          td \( \vec{a} \cdot \vec{b} \)
          td: code &amp;v a &amp;. &amp;v b
          td
          td.center 15
          td.center Non
        tr
          td Cross Product
          td \( \vec{a} \times \vec{b} \)
          td: code &amp;v a &amp;x &amp;v b
          td
          td.center 16
          td.center Non
        tr
          td Wedge Product
          td \( \vec{a} \wedge \vec{b} \)
          td: code &amp;v a &amp;w &amp;v b
          td
          td.center 16
          td.center Non
        tr
          td Tensor Product
          td \( T \otimes S \)
          td: code T &amp;ox S
          td
          td.center 16
          td.center Non
        tr
          td Cartesian Product
          td \( A \times B \)
          td: code A &amp;* B
          td
          td.center 16
          td.center 16
        tr
          td Direct Sum
          td \( A \oplus B \)
          td: code A &amp;o+ B
          td
          td.center 11
          td.center Left
        tr
          td(rowspan=2) Universal Quantifier
          td \( \forall x \) (we have) \( P(x) \)
          td: code forall x -> P(x)
          td(rowspan=2) "For all &hellip;"
          td.center(rowspan=2) 6
          td.center(rowspan=2) Left
        tr
          td \( \forall x \) (such that) \( Q(x) \) (we have) \( P(x) \)
          td: code forall x : Q(x) -&gt; P(x)
        tr
          td Existential Quantifier
          td \( \exists x \) (such that) \( Q(x) \)
          td: code exists x : Q(x)
          td "There exists &hellip; such that"
          td.center 6
          td.center Left
        tr
          td Unique Quantifier
          td \( \exists ! x \) (such that) \( Q(x) \)
          td: code unique x : Q(x)
          td "There exists a unique &hellip; such that"
          td.center 6
          td.center Left

    p.
      As previously stated, all relations are non-associative since <code>a = b = c = d</code> is
      <em>NOT</em> the same as <code>((a = b) = c) = d</code> or <code>a = (b = (c = d))</code>. Later
      versions of MathLex may support such expressions as syntactic sugar for
      <code>(a = b) and (b = c) and (c = d)</code>

    table#relations
      caption Relations
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
          th Precedence
          th Associativity
      tbody
        tr
          td Equal
          td \( = \)
          td: code
            | =, ==
          td
          td.center 7
          td.center Non
        tr
          td Not Equal
          td \( \ne \)
          td: code !=, /=, &lt;&gt;
          td
          td.center 7
          td.center Non
        tr
          td Less Than
          td \( &lt; \)
          td: code &lt;
          td
          td.center 7
          td.center Non
        tr
          td Greater Than
          td \( &gt; \)
          td: code &gt;
          td
          td.center 7
          td.center Non
        tr
          td Less Than or Equal
          td \( \le \)
          td: code &lt;=
          td
          td.center 7
          td.center Non
        tr
          td Greater Than or Equal
          td \( \ge \)
          td: code &gt;=
          td
          td.center 7
          td.center Non
        tr
          td Divides
          td \( p \mid q \)
          td: code p|q, p divides q
          td
          td.center 7
          td.center Non
        tr
          td Not Divides
          td \( p \nmid q \)
          td: code p~|q, p/|q, p ndivides q, p ndivide q, p notdivides q, p notdivide q
          td
          td.center 7
          td.center Non
        tr
          td Ratio Equality
          td \( \mathrm{as} \)
          td: code as
          td
          td.center 7
          td.center Non
        tr
          td Subset
          td \( \subseteq \)
          td: code subset
          td
          td.center 7
          td.center Non
        tr
          td Superset
          td \( \supseteq \)
          td: code superset, supset
          td
          td.center 7
          td.center Non
        tr
          td Proper Subset
          td \( \subset \)
          td: code propersubset, propsubset, psubset
          td
          td.center 7
          td.center Non
        tr
          td Proper Superset
          td \( \supset \)
          td: code propersuperset, propsuperset, psuperset, propersupset, propsupset, psupset
          td
          td.center 7
          td.center Non
        tr
          td Inclusion
          td \( \in \)
          td: code in
          td
          td.center 7
          td.center Non
        tr
          td Congruent
          td \( \cong \)
          td: code ~=, congruent
          td
          td.center 7
          td.center Non
        tr
          td Similar
          td \( \sim \)
          td: code ~, sim, similar
          td
          td.center 7
          td.center Non
        tr
          td Parallel
          td \( \parallel \)
          td: code para, parallel
          td
          td.center 7
          td.center Non
        tr
          td Perpendicular
          td \( \perp \)
          td: code perp, perpendicular
          td
          td.center 7
          td.center Non
        tr
          td Equivalent
          td \( \equiv \)
          td: code
            | ===, equiv
          td
          td.center 0
          td.center Non
        tr
          td Not Equivalent
          td \( \not\equiv \)
          td: code !==, /==, nequiv
          td
          td.center 0
          td.center Non

    table#delimiters
      caption Delimiters and Indexing
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Parentheses
          td \( \left( \ \right) \)
          td: code ( )
          td Order of operation
        tr
          td Square Brackets
          td \( \left[ \ \right] \)
          td: code [ ]
          td Lists
        tr
          td Curly Braces
          td \( \left\{ \ \right\} \)
          td: code { }
          td Sets
        tr
          td Angle Brackets
          td \( \left\langle \ \right\rangle \)
          td: code &lt; &gt;, &lt;: :&gt;
          td Vectors
        tr
          td Vertical Bars
          td \( \left| \ \right| \)
          td: code | |, |: :|
          td Absolute Value, Length, Determinant, Norm
        tr
          td Double Bars
          td \( \left\| \ \right\| \)
          td: code || ||, ||: :||
          td Length, Norm
        tr
          td Floor
          td \( \left\lfloor x \right\rfloor \)
          td: code floor(x)
        tr
          td Ceiling
          td \( \left\lceil x \right\rceil \)
          td: code ceil(x), ceiling(x)
          td
        tr
          td Subscript
          td \( a_b \)
          td: code a &amp;_ b
          td(rowspan=2) Indexing
        tr
          td Multiple Subscript
          td \( a_{i,j,k} \)
          td: code a &amp;_ [i,j,k]
        tr
          td Superscript
          td \( a^b \)
          td: code a &amp;^ b
          td(rowspan=2) Indexing
        tr
          td Multiple Superscript
          td \( a^{i,j,k} \)
          td: code a &amp;^ [i,j,k]
        tr
          td Mixed Subscripts and Superscripts
          td \( T{}^i{}_j{}}^k \)
          td
          td
        tr
          td Open Interval
          td \( \left( a,b \right) \)
          td: code (:a,b:)
          td Exclusive Range Delimiters
        tr
          td Closed Interval
          td \( \left[ a,b \right] \)
          td: code [:a,b:]
          td Inclusive Range Delimiters
        tr
          td Half-Open Interval
          td \( \left[ a,b \right) \)
          td: code [:a,b:)
          td Mixed Range Delimiters
        tr
          td Bra-Ket Notation
          td \( \left\langle A \mid B \right\rangle \)
          td: code &lt;A||B&gt;, &lt;:A|B:&gt;
          td
        tr
          td Bra
          td \( \left\langle A \right| \)
          td: code &lt;A|
          td
        tr
          td Ket
          td \( \left| A \right\rangle \)
          td: code |A&gt;
          td

    p.
      Note that some delimiters have more than one format either with or without colons. Namely, absolute
      value can be written as <code>| &hellip; |</code> or <code>|: &hellip; :|</code>, norm can be
      written as <code>|| &hellip; ||</code> or <code>||: &hellip; :||</code>, and vectors can
      be surrounded by either <code>&lt; &hellip; &gt;</code> or <code>&lt;: &hellip; :&gt;</code>.
      Those with colons are <em>matched pairs</em> and should be used whenever there might be a chance
      of confusion about pairing. Those without colons are <em>context-sensitive</em> in that they
      have different meanings and therefore cannot be automatically matched by the Lexer. Additionally,
      if an expression opened with one type of delimiter, it must be closed with the same type (i.e.
      context-aware vs. matched).

    p All delimiters have "infinite" precedence; any and all contents will be grouped together.

    table#functions
      caption Functions
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Trig
          td \( \sin(\theta) \), &hellip;
          td: code sin(theta), &hellip;
          td Also cos, tan, cot, sec, csc
        tr
          td Inverse Trig
          td \( \arcsin(x) \), &hellip;
          td: code arcsin(x), &hellip;
          td Also arccos, arctan, arccot, arcsec, arccsc
        tr
          td Hyperbolic Trig
          td \( \sinh(\lambda) \), &hellip;
          td: code sinh(lambda), &hellip;
          td Also cosh, tanh, coth, sech, csch
        tr
          td Inv. Hyp. Trig
          td \( \mathrm{arcsinh}(x) \), &hellip;
          td: code arcsinh(x), &hellip;
          td Also arccosh, arctanh, arccoth, arcsech, arccsch
        tr
          td Absolute Value
          td \( \left| a \right| \)
          td: code abs(a)
        tr
          td Floor
          td \( \left\lfloor x \right\rfloor \)
          td: code floor(x)
        tr
          td Ceiling
          td \( \left\lceil x \right\rceil \)
          td: code ceil(x), ceiling(x)
        tr
          td Square Root
          td \( \sqrt{a} \)
          td: code sqrt(a)
        tr
          td \(n\)th Root
          td \( \sqrt[n]{a} \)
          td: code root(a, n)
        tr
          td Natural Exponential
          td \( \exp(a) \)
          td: code exp(a)
        tr
          td Natural Logarithm
          td \( \ln(a) \)
          td: code ln(a)
        tr
          td Logarithm with Base
          td \( \log_b{a} \)
          td: code log(a, b)
        tr
          td Combination
          td \( \binom{n}{r} \)
          td: code C(n,r)
          td Binomial Coefficient, ``choose''
        tr
          td Permutation
          td \( P(n,r) \)
          td: code P(n,r)
        tr
          td Limit
          td \( \displaystyle\lim_{x\to a} f(x) \)
          td: code lim(f(x), a, x), limit(f(x), x, a)
        tr
          td Derivative
          td \( \displaystyle \frac{\mathrm{d}}{\mathrm{d}x} \left( f(x) \right) \)
          td: code diff(f(x), x)
        tr
          td Partial Derivative
          td \( \displaystyle \frac{\partial}{\partial x} \left( f(x,y) \right) \)
          td: code pdiff(f(x,y), x)
        tr
          td Indefinite Integral
          td \( \displaystyle \int f(x) \,\mathrm{d}x \)
          td: code int(f(x),x), &amp;int f(x) &amp;dx
        tr
          td Definite Integral
          td \( \displaystyle \int_a^b f(x) \,\mathrm{d}x \)
          td: code int(f(x),x,a,b), &amp;int &amp;_a &amp;^b f(x) &amp;dx
        tr
          td Sum Over Set
          td \( \displaystyle \sum_{i \in S} a_i \)
          td: code sum(a&amp;_i, i in S)
        tr
          td Sum Over Range
          td \( \displaystyle \sum_{i=a}^b a_i \)
          td: code sum(a&amp;_i,i,a,b)
        tr
          td Product Over Set
          td \( \displaystyle \prod_{i \in S} a_i \)
          td: code prod(a&amp;_i, i in S), product(a&amp;_i, i in S)
        tr
          td Product Over Range
          td \( \displaystyle \prod_{i=a}^b a_i \)
          td: code prod(a&amp;_i,a,b), product(a&amp;_i,a,b)

  section#by-topic
    h2 Symbols by Topic

block javascripts
    script(src='http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML')

