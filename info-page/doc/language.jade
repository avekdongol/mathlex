extends layout

block append vars
  next_page = {href: 'how-mathlex-works.html', title: 'How MathLex Works'}

block article
  :markdown
    # Language Specification

    This section describes the syntax used to enter mathematical content into MathLex. All input consists of
    _Tokens_ or strings of characters representing mathematical symbols or quantities. For example, the token
    '`>=`' represents the mathematical symbol &ge; and the concept "greater than or equal to". Tokens in
    the input string may be separated by spaces, but MathLex is intelligent enough to automatically separate tokens in
    _most_ cases. MathLex looks for tokens in a greedy fashion in which it tries to match the largest token
    possible. For example `5!=120` would be interpreted as 5 &ne; 120 even though the intended meaning might
    have been 5! = 120. Therefore, it is necessary to insert spaces to separate tokens that might be part of other
    tokens.

    The basic types of tokens in MathLex are Numbers (further subdivided into Integers and Floats/Decimals), Identifiers
    (further subdivided into Keywords and Variables), Constants, and Operators. After these basic types are defined, the
    collection of all tokens is presented in two sets of tables: the first is organized by how symbols are used in
    mathematics (e.g. binary operators, relations, etc.); the second is organized by topic (e.g. calculus, set theory,
    etc.). The second set of tables is redundant but included for clarity.

  h2 Section Contents
  nav.toc
    ul
      li: a(href='#summary') Summary
        ul
          li: a(href='#numbers') Numbers
          li: a(href='#identifiers') Identifiers
          li: a(href='#constants') Constants
          li: a(href='#operators') Operators
      li: a(href='#by-type') Symbols by Type
        ul
          li: a(href='#constants') Constants
          li: a(href='#unary') Unary Operators
          li: a(href='#binary') Binary Operators
          li: a(href='#relations') Relations
          li: a(href='#delimiters') Delimiters
          li: a(href='#functions') Functions
      li: a(href='#by-topic') Symbols by Topic
        ul
          li: a(href='#arithmetic') Arithmetic
          li: a(href='#algebra') Algebra
          li: a(href='#geometry') Geometry
          li: a(href='#trigonometry') Trigonometry
          li: a(href='#discrete') Discrete
          li: a(href='#calculus') Calculus
          li: a(href='#set-theory') Set Theory
          li: a(href='#logic') Logic
          li: a(href='#linear-algebra') Linear Algebra

  :markdown
    ## Numbers

    A _Number_ is exactly as it seems: `42`, `3.14`, etc. Scientific notation is also allowed: `5e-2`, `3.0E8`. In
    either case, decimal points do not need a leading or trailing zero: `.5`, `78.`, `9.E-4`, `.22E7`.

    Note that negative numbers are treated as a negation operation on the positive value of the number (consistent with
    algebraic notation). Likewise, fractions are treated as division operations on whole numbers.

    ## Identifiers

    An _Identifier_ is an upper- or lowercase letter followed by any number of upper- or lowercase letters, numbers, or
    underscores (`_`). All of the following are valid identifiers: `x`, `A`, `b0`, `my_var`, `infinity`, `union`, and
    `arccos`. Identifiers fall under two categories: reserved and unreserved. Reserved identifiers, also called
    keywords, may be synonyms for certain constants or operators or may be the names of known functions. Each keyword for
    a constant or operator has its own token. They are listed in the
    [Table of Reserved Constant and Operator Keywords](#reserved-constant-and-operator-keywords) below and again later
    in the [Table of Constants](#constants) and the [Operator Tables](#unary). The keywords for known functions are
    assigned as _TIdentifier_ tokens and are treated as general functions by the parser. They only get treated as
    specific functions by the translators and renderers. These function names are listed in the
    [Table of Reserved Function Name Keywords](#reserved-function-name-keywords) below and again later in the
    [Table of Functions](#functions) (and occasionally in other tables). Unreserved identifiers may be used as variables
    or user-defined functions. Of the above identifiers, `infinity` is a constant keyword, `union` is an operator
    keyword, and `arccos` is a known function keyword, while the rest are valid variable or user-defined function names.

  table#reserved-constant-and-operator-keywords
    caption Reserved Constant and Operator Keywords
    for row in [['and', 'as', 'congruent', 'divides', 'equiv', 'exists', 'false' ], ['forall', 'if', 'iff', 'impliedby', 'implies', 'in', 'infinity' ], ['intersect', 'minus', 'mod', 'ndivide', 'ndivides', 'nequiv', 'not' ], ['notdivide', 'notdivides', 'onlyif', 'or', 'para', 'parallel', 'perp' ], ['perpendicular', 'propersubset', 'propersuperset', 'propersupset', 'propsubset', 'propsuperset', 'propsupset' ], ['psubset', 'psuperset', 'psupset', 'sim', 'similar', 'subset', 'superset' ], ['supset', 'then', 'true', 'union', 'unique', 'when', '&nbsp;' ]]
      tr: for word in row
        td!= word

  table#reserved-function-name-keywords
    caption Reserved Function Name Keywords
    for row in [['abs', 'acos', 'acosh', 'acot', 'acoth', 'acsc', 'acsch',], ['arccos', 'arccosh', 'arccot', 'arccoth', 'arccsc', 'arccsch', 'arcsec',], ['arcsech', 'arcsin', 'arcsinh', 'arctan', 'arctanh', 'asec', 'asech',], ['asin', 'asinh', 'atan', 'atanh', 'C', 'ceil', 'ceiling',], ['cos', 'cosh', 'cot', 'coth', 'csc', 'csch', 'curl',], ['diff', 'div', 'exp', 'floor', 'gamma', 'grad', 'int',], ['int', 'Integral', 'integral', 'Intersect', 'lim', 'limit', 'ln',], ['log', 'P', 'pdiff', 'prod', 'product', 'root', 'sec',], ['sech', 'sin', 'sinh', 'sqrt', 'sum', 'tan', 'tanh',], ['Union', '&nbsp;', '&nbsp;', '&nbsp;', '&nbsp;', '&nbsp;', '&nbsp;']]
      tr: for word in row
        td!= word
  :markdown
    ## Constants

    Similar to identifiers, _Constants_ are globally defined values or constructs. In MathLex, constants are typed as a
    number sign (`#`; also called _hash_, _sharp_, or _pound_) followed by the name of the constant. For example, in MathLex, one
    would type `#pi` (or `#p` for short) to represent "pi" (\\( \pi \\)) and `#R` to represent the set of real numbers
    (\\( \mathbb{R} \\)). See the [Table of Constants](#constants) below for a comprehensive list.

    ## Operators

    An _Operator_ is just a catch-all term for any symbol that is not a Number, Identifier, or Constant, but is
    generally a mathematical operation or delimiter. With the exception of a few reserved keywords, operators usually
    consist of a few non-alphanumeric characters. Some operators start with an ampersand (`&`) to distinguish them from
    similar symbols. Some mathematical operators can be represented in multiple ways in MathLex. The following tables
    outline all mathematical operators understood by MathLex and all ways to represent them. Pick your favorite.

    The numbers in the `Precedence` column of operator tables reflect which operations are more tightly bound
    (e.g. the "<abbr title="Parentheses, Exponents, Multiplication, Division, Addition, Subtraction">PEMDAS</abbr>"
    order of operations from grade school mathematics). Operators of higher precedence (greater numerical value) will be
    identified and grouped before operators with lower precedence (lesser numerical value). Operators of equal
    precedence will be grouped as they are found according to their associativity.

    for unary and binary operators, the precedence number is followed by an indicator of _Associativity_, i.e. how
    chained operations would be bound together:

    * Left-associative operators will be grouped from left to right (like subtraction and division):
      `a-b-c-d = ((a-b)-c)-d`
    * Right-associative operators will be grouped from right to left (like exponents): `a^b^c^d = a^(b^(c^d))`.
    * Non-associative operators cannot be chained. For example, the triple dot product `&v a &. &v b &. &v c` does not
      make any sense since the result of a dot product is a scalar.
    * Associative operators (like addition and multiplication) may be considered left- or right-associative without loss
      of meaning. However, MathLex handles such operators as left-associative for definiteness.

    At present, MathLex cannot chain relations, so they are regarded as non-associative.

    **A special note about Functions.** Functions receive special treatment in that a majority of them are tokenized
    initially as unreserved identifiers and then interpreted after being parsed, but some functions have special tokens
    and syntax. Traditionally, functions are identifiers appended with a parenthesized list of parameters, e.g.
    `f(x,yz)`. Some functions like _sum_, _product_, and _limit_ have alternate notations that closely mimic handwritten
    notation and are thus called "written syntax". For example, the traditional CAS-like function to represent
    \\( \displaystyle \sum\_{x=0}^n \frac{1}{x} \\) in MathLex is `sum(1/x, x, 0, n)` and MathLex's alternate written
    syntax is `&sum &_(x=0) &^n 1/x`. Both are accepted by MathLex.

    Function operators like composition and builder notation, e.g. \\( (f \circ g + h)(x) \\), are allowed, so function
    application is parsed as a parenthetical postfix. See the note below the [Table of Unary Operators](#unary) for more
    information.


  section#by-type
    h2 Symbols by Type

    h3#constants Constants
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Pi
          td \( \pi \)
          td: code #pi, #p
          td 3.14&hellip;
        tr
          td Tau
          td \( \tau \)
          td: code #tau
          td \( 2 \pi \) &asymp; 6.28&hellip;
        tr
          td E
          td \( \mathrm{e} \)
          td: code #e
          td 2.718&hellip;, Natural Base, Euler-Napier number
        tr
          td Gamma
          td \( \gamma \)
          td: code #gamma
          td 0.577&hellip;, Euler-Mascheroni constant
        tr
          td Infinity
          td \( \infty \)
          td: code #infinity, infinity
          td: code.error ERROR: memory overflow
        tr
          td Imaginary Unit
          td \( i \)
          td: code #i
          td \( \sqrt{-1} \)
        tr
          td True
          td \( \mathbf{T} \)
          td: code #T, #true, true
          td Case-insensitive
        tr
          td False
          td \( \mathbf{F} \)
          td: code #F, #false, false
          td Case-insensitive
        tr
          td Natural Numbers
          td \( \mathbb{N} \)
          td: code #N
          td
        tr
          td Integer Ring
          td \( \mathbb{Z} \)
          td: code #Z
          td
        tr
          td Rational Field
          td \( \mathbb{Q} \)
          td: code #Q
          td
        tr
          td Real Field
          td \( \mathbb{R} \)
          td: code #R
          td
        tr
          td Complex Field
          td \( \mathbb{C} \)
          td: code #C
          td
        tr
          td Quaternion Ring
          td \( \mathbb{H} \)
          td: code #H
          td Hamilton numbers
        tr
          td Octonian Algebra
          td \( \mathbb{O} \)
          td: code #O
          td Cayley numbers, Type "Oh"
        tr
          td Universal Set
          td \( \mathbb{U} \)
          td: code #U
          td
        tr
          td Empty Set
          td \( \emptyset \)
          td: code #empty, {}
          td
        tr
          td Zero Vector
          td \( \vec{0} \)
          td: code #v0
          td
        tr
          td \( x \) Unit Vector
          td \( \hat{\imath} \)
          td: code #ui, #vi
          td
        tr
          td \( y \) Unit Vector
          td \( \hat{\jmath} \)
          td: code #uj, #vj
          td
        tr
          td \( z \) Unit Vector
          td \( \hat{k} \)
          td: code #uk, #vk
          td
        tr
          td Zero Matrix
          td \( \mathbf{0} \)
          td: code #0
          td Type "zero"
        tr
          td Unit Matrix
          td \( \mathbf{I} \)
          td: code #1
          td Identity Matrix, Type "one"

    h3#unary Unary Operators
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
          th Precedence
          th Associativity
      tbody
        tr
          td Positive
          td \( +a \)
          td: code +a
          td
          td.center 17
          td.center Right
        tr
          td Negative
          td \( -a \)
          td: code -a
          td
          td.center 17
          td.center Right
        tr
          td Positive/Negative
          td \( \pm a \)
          td: code +/-a, &amp;pm a
          td
          td.center 17
          td.center Right
        tr
          td Negative/Positive
          td \( \mp a \)
          td: code -/+, &amp;mp a
          td
          td.center 17
          td.center Right
        tr
          td Square Root
          td \( \sqrt{a} \)
          td: code sqrt(a)
          td
          td.center *
          td.center *
        tr
          td Factorial
          td \( n! \)
          td: code a!
          td
          td.center 21
          td.center Left
        tr
          td Natural Exponential
          td \( \exp(a) \)
          td: code exp(a)
          td
          td.center *
          td.center *
        tr
          td Natural Logarithm
          td \( \ln(a) \)
          td: code ln(a)
          td
          td.center *
          td.center *
        tr
          td Real Part
          td \( \Re a \)
          td: code &amp;Re a
          td
          td.center 17
          td.center Right
        tr
          td Not
          td \( \neg p \)
          td: code ~p, !p, not p
          td Logical Negation
          td.center 17
          td.center Right
        tr
          td Prime derivative
          td \( f' \)
          td: code f'
          td Derivative w.r.t. \( x \) or first or only variable
          td.center 21
          td.center Left
        tr
          td Dot derivative
          td \( \dot{f} \)
          td: code f.
          td Derivative w.r.t. \( t \) or second variable
          td.center 21
          td.center Left
        tr
          td Change
          td \( \Delta x \)
          td: code &amp;D x
          td Coordinate Difference
          td.center 17
          td.center Non
        tr
          td Differential
          td \( \mathrm{d} x \)
          td: code &amp;d x
          td
          td.center 17
          td.center Non
        tr
          td Partial Differential
          td \( \partial x \)
          td: code &amp;pd x
          td
          td.center 17
          td.center Non
        tr
          td Vector
          td \( \vec{a} \)
          td: code &amp;v a
          td
          td.center 17
          td.center Non
        tr
          td Unit Vector
          td \( \hat{a} \)
          td: code &amp;u a
          td
          td.center 17
          td.center Non
        tr
          td Gradient
          td \( \vec{\nabla} f \), \( \mathrm{grad}(f) \)
          td: code &amp;del f, grad(f)
          td
          td.center 17
          td.center Right
        tr
          td Divergence
          td \( \vec{\nabla} \cdot F \), \( \mathrm{div}(F) \)
          td: code &amp;del. F, div(F)
          td
          td.center 17
          td.center Non
        tr
          td Curl
          td \( \vec{\nabla} \times F \), \( \mathrm{curl}(F) \)
          td: code &amp;delx F, curl(F)
          td
          td.center 17
          td.center Right

    p.
      Note that all prefix operators are <strong>right-associative</strong> and all postfix operators are
      <strong>left-associative</strong>.

    p.
      * Although not listed, a pair of parentheses, when used as a function application, may be considered a postfix
      unary operator. As such, it is <strong>left-associative</strong> and has a precedence of <strong>18</strong>, just
      below that of function composition and exponents.

    h3#binary Binary Operators
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
          th Precedence
          th Associativity
      tbody
        tr
          td Plus
          td \( a + b \)
          td: code a + b
          td Addition
          td.center 9
          td.center Left
        tr
          td Minus
          td \( a - b \)
          td: code a - b
          td Subtraction
          td.center 9
          td.center Left
        tr
          td Plus/Minus
          td \( a \pm b \)
          td: code a +/- b, a &amp;pm b
          td
          td.center 9
          td.center Left
        tr
          td Minus/Plus
          td \( a \mp b \)
          td: code a -/+ b, a &amp;mp b
          td
          td.center 9
          td.center Left
        tr
          td Times
          td \( a \cdot b \)
          td: code a * b
          td Multiplication
          td.center 14
          td.center Left
        tr
          td Divided by
          td \( \frac{a}{b} \), \( a/b \)
          td: code a/b, a &amp;/ b
          td Division
          td.center 14
          td.center Left
        tr
          td Power
          td \( a^b \)
          td: code a^b, a**b
          td Exponentiation
          td.center 20
          td.center Right
        tr
          td \( n \)-th Root
          td \( \sqrt[n]{a} \)
          td: code root(a, n)
          td
          td.center *
          td.center *
        tr
          td Logarithm with Base
          td \( \log_b{a} \)
          td: code log(a, b)
          td
          td.center *
          td.center *
        tr
          td Ratio
          td \( p : q \)
          td: code p&amp;:q
          td
          td.center 8
          td.center Non
        tr
          td Modulus
          td \( a \pmod{n} \)
          td: code a%n, a mod n
          td
          td.center 14
          td.center Left
        tr
          td Combination
          td \( \binom{n}{r} \)
          td: code C(n,r), combination(n,r), n choose r
          td Binomial Coefficient; choose; <tt>comb</tt> for short
          td.center *
          td.center *
        tr
          td Permutation
          td \( P(n,r) \)
          td: code P(n,r), permutation(n,r)
          td <tt>perm</tt> for short
          td.center *
          td.center *
        tr
          td Function Composition
          td \( f \circ g \)
          td: code f @ g
          td
          td.center 19
          td.center Left
        tr
          td Function Repeated Composition
          td \( f^{\circ n} \)
          td: code f @@ n
          td not implemented
          td.center 20
          td.center Right
        tr
          td Dot Product
          td \( \vec{a} \cdot \vec{b} \)
          td: code &amp;v a &amp;. &amp;v b
          td
          td.center 15
          td.center Non
        tr
          td Cross Product
          td \( \vec{a} \times \vec{b} \)
          td: code &amp;v a &amp;x &amp;v b
          td
          td.center 16
          td.center Left
        tr
          td Wedge Product
          td \( \vec{a} \wedge \vec{b} \)
          td: code &amp;v a &amp;w &amp;v b
          td
          td.center 16
          td.center Left
        tr
          td Tensor Product
          td \( T \otimes S \)
          td: code T &amp;ox S
          td
          td.center 16
          td.center Left
        tr
          td Cartesian Product
          td \( A \times B \)
          td: code A &amp;* B, A &amp;x B
          td
          td.center 16
          td.center Left
        tr
          td Direct Sum
          td \( A \oplus B \)
          td: code A &amp;o+ B
          td
          td.center 11
          td.center Left
        tr
          td Subscript
          td \( a_b \)
          td: code a&amp;_b
          td(rowspan=2) Indexing
          td.center(rowspan=2) 22
          td.center(rowspan=2) Left
        tr
          td Multiple Subscript
          td \( a_{i,j,k} \)
          td: code a &amp;_[i,j,k]
        tr
          td Superscript
          td \( a^b \)
          td: code a&amp;^b
          td(rowspan=2) Indexing
          td.center(rowspan=2) 22
          td.center(rowspan=2) Left
        tr
          td Multiple Superscript
          td \( a^{i,j,k} \)
          td: code a &amp;^[i,j,k]
        tr
          td Mixed Subscripts and Superscripts
          td \( T{}^i{}_j{}^k \)
          td: code T &amp;^i &amp;_j &amp;^k
          td Tensor Indexing
          td
          td
        tr
          td Union
          td \( a \cup b \)
          td: code a union b
          td
          td.center 12
          td.center Left
        tr
          td Intersection
          td \( a \cap b \)
          td: code a intersect b
          td
          td.center 13
          td.center Left
        tr
          td Set Difference
          td \( a \setminus b \)
          td: code a \ b, a minus b
          td
          td.center 10
          td.center Left

    h3#logical-connectives Logical Connectives and Quantifiers
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
          th Precedence
          th Associativity
      tbody
        tr
          td And
          td \( p \wedge q \)
          td: code p &amp;&amp; q, p and q
          td Conjugation
          td.center 5
          td.center Left
        tr
          td Or
          td \( p \vee q \)
          td: code p || q, p or q
          td Disjunction
          td.center 3
          td.center Left
        tr
          td Exclusive Or
          td \( p \veebar q \)
          td: code p xor q
          td Exclusion
          td.center 4
          td.center Left
        tr
          td Implies
          td \( p \rightarrow q \)
          td: code p -&gt; q, p implies q, p onlyif q, if p then q
          td Conditional
          td.center 2
          td.center Left
        tr
          td Implied By
          td \( p \leftarrow q \)
          td: code p &lt;- q, p imqliedby q, p if q, p when q, p whenever q
          td Reverse Conditional
          td.center 2
          td.center Left
        tr
          td If And Only If
          td \( p \leftrightarrow q \)
          td: code p &lt;-&gt; q, p iff q
          td Biconditional
          td.center 1
          td.center Non
        tr
          td Such That
          td \( p : q \)
          td: code p:q
          td Used with set builder and quantifiers
          td
          td
        tr
          td(rowspan=2) Universal Quantifier
          td \( \forall x \) (we have) \( P(x) \)
          td: code forall x -> P(x)
          td(rowspan=2) "For all &hellip;"
          td.center(rowspan=2) 6
          td.center(rowspan=2) Left
        tr
          td \( \forall x :~Q(x) \) (we have) \( P(x) \)
          td: code forall x : Q(x) -&gt; P(x)
        tr
          td Existential Quantifier
          td \( \exists x :~Q(x) \)
          td: code exists x : Q(x)
          td "There exists &hellip; such that &hellip;"
          td.center 6
          td.center Left
        tr
          td Unique Quantifier
          td \( \exists ! x :~Q(x) \)
          td: code unique x : Q(x)
          td "There exists a unique &hellip; such that &hellip;"
          td.center 6
          td.center Left

    h3#relations Relations
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Precedence
      tbody
        tr
          td Equal
          td \( a = b \)
          td: code
            | a = b, a == b
          td.center 7
        tr
          td Not Equal
          td \( a \ne b \)
          td: code a /= b, a != b, a &lt;&gt; b
          td.center 7
        tr
          td Less Than
          td \( a &lt; b \)
          td: code a &lt; b
          td.center 7
        tr
          td Greater Than
          td \( a &gt; b \)
          td: code a &gt; b
          td.center 7
        tr
          td Less Than or Equal
          td \( a \le b \)
          td: code a &lt;= b
          td.center 7
        tr
          td Greater Than or Equal
          td \( a \ge b \)
          td: code a &gt;= b
          td.center 7
        tr
          td Divides
          td \( p \mid q \)
          td: code p|q, p divides q
          td.center 7
        tr
          td Not Divides
          td \( p \nmid q \)
          td: code p/|q, p~|q, p ndivides q, p ndivide q, p notdivides q, p notdivide q
          td.center 7
        tr
          td Ratio Equality
          td \( a:b :: c:d\)
          td: code a&amp;:b :: c&amp;:d, a&amp;:b as c&amp;:d
          td.center 7
        tr
          td Congruent
          td \( A \cong B \)
          td: code A ~= B, A congruent B
          td.center 7
        tr
          td Similar
          td \( A \sim B \)
          td: code A ~ B, A sim B, A similar B
          td.center 7
        tr
          td Parallel
          td \( A \parallel B \)
          td: code A para B, A parallel B
          td.center 7
        tr
          td Perpendicular
          td \( A \perp B \)
          td: code A perp B, A perpendicular B
          td.center 7
        tr
          td Subset
          td \( A \subseteq B \)
          td: code A subset B
          td.center 7
        tr
          td Superset
          td \( A \supseteq B \)
          td: code A superset B, A supset B
          td.center 7
        tr
          td Proper Subset
          td \( A \subset B \)
          td: code A propersubset B, A propsubset B, A psubset B
          td.center 7
        tr
          td Proper Superset
          td \( A \supset B \)
          td: code A propersuperset B, A propsuperset B, A psuperset B, A propersupset B, A propsupset B, A psupset B
          td.center 7
        tr
          td Inclusion
          td \( a \in A \)
          td: code a in A
          td.center 7
        tr
          td Equivalent
          td \( A \equiv B \)
          td: code
            | A === B, A equiv B
          td.center 0
        tr
          td Not Equivalent
          td \( A \not\equiv B \)
          td: code A /== B, A !== B, A nequiv B
          td.center 0

    p.
      As previously stated, all relations are <strong>non-associative</strong> since <code>a = b = c = d</code> is
      <em>NOT</em> the same as <code>((a = b) = c) = d</code> or <code>a = (b = (c = d))</code>. Later versions of
      MathLex may support such expressions as <code>a = b = c = d</code> to be "syntactic sugar" for <code>(a = b) and
      (b = c) and (c = d)</code>

    h3#delimiters Delimiters and Indexing
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Parentheses
          td \( \left( \ \right) \)
          td: code ( )
          td Order of operation
        tr
          td Curly Braces
          td \( \left\{ \ \right\} \)
          td: code { }
          td Sets
        tr
          td Square Brackets
          td \( \left[ \ \right] \)
          td: code [ ]
          td Lists
        tr
          td Angle Brackets
          td \( \left\langle \ \right\rangle \)
          td: code &lt; &gt;, &lt;: :&gt;
          td Vectors
        tr
          td(rowspan=2) Matrix
          td \( \left[ \left\langle \ \right\rangle, \left\langle \ \right\rangle \right] \)
          td: code [&lt; &gt;, &lt; &gt;], [&lt;: :&gt;, &lt;: :&gt;]
          td Row of Columns
        tr
          td \( \left\langle \left[ \right], \left[ \right] \right\rangle \)
          td: code [&lt; &gt;, &lt; &gt;], [&lt;: :&gt;, &lt;: :&gt;]
          td Column of Rows
        tr
          td Vertical Bars
          td \( \left| \ \right| \)
          td: code | |, |: :|
          td Absolute Value, Length, Determinant, Norm
        tr
          td Double Bars
          td \( \left\| \ \right\| \)
          td: code || ||, ||: :||
          td Length, Norm
        tr
          td Floor
          td \( \left\lfloor x \right\rfloor \)
          td: code floor(x)
        tr
          td Ceiling
          td \( \left\lceil x \right\rceil \)
          td: code ceil(x), ceiling(x)
          td
        tr
          td Such That
          td \( p : q \)
          td: code p:q
          td Used with set builder and quantifiers
        tr
          td List Separator
          td \( , \)
          td: code ,
          td
        tr
          td Subscript
          td \( a_b \)
          td: code a &amp;_b
          td(rowspan=2) Indexing
        tr
          td Multiple Subscript
          td \( a_{i,j,k} \)
          td: code a &amp;_[i,j,k]
        tr
          td Superscript
          td \( a^b \)
          td: code a &amp;^b
          td(rowspan=2) Indexing
        tr
          td Multiple Superscript
          td \( a^{i,j,k} \)
          td: code a &amp;^[i,j,k]
        tr
          td Mixed Subscripts and Superscripts
          td \( T{}^i{}_j{}^k \)
          td: code T &amp;^i &amp;_j &amp;^k
          td Tensor Indexing
        tr
          td Open Interval
          td \( \left( a,b \right) \)
          td: code (:a,b:)
          td Exclusive Range Delimiters
        tr
          td Closed Interval
          td \( \left[ a,b \right] \)
          td: code [:a,b:]
          td Inclusive Range Delimiters
        tr
          td Half-Open Interval
          td \( \left[ a,b \right) \)
          td: code [:a,b:)
          td Mixed Range Delimiters
        tr
          td Bra-Ket Notation
          td \( \left\langle A \mid B \right\rangle \)
          td: code &lt;A||B&gt;, &lt;:A|B:&gt;
          td
        tr
          td Bra
          td \( \left\langle A \right| \)
          td: code &lt;A|
          td
        tr
          td Ket
          td \( \left| B \right\rangle \)
          td: code |B&gt;
          td

    p.
      Note that some delimiters have more than one format either with or without colons. Namely, absolute value can be
      written as <code>| |</code> or <code>|: :|</code>, norm can be written as <code>|| ||</code> or
      <code>||: :||</code>, and vectors can be surrounded by either <code>&lt; &gt;</code> or <code>&lt;: :&gt;</code>.
      Those with colons are <em>matched pairs</em> and should be used whenever there might be a chance of confusion
      about pairing. Those without colons are <em>context-sensitive</em> in that they have multiple meanings and
      therefore may not be automatically matched by the Lexer. Additionally, if an expression opened with one type of
      delimiter, it must be closed with the same type (i.e. matched vs. context-sensitive).

    p All delimiters have "infinite" precedence; any and all contents will be grouped together.

    h3#functions Functions
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Trig
          td \( \sin(\theta) \), &hellip;
          td: code sin(theta), &hellip;
          td Also cos, tan, cot, sec, csc
        tr
          td Inverse Trig
          td \( \arcsin(x) \), &hellip;
          td: code arcsin(x), asin(x), &hellip;
          td Also arccos, acos, arctan, atan, arccot, acot, arcsec, asec, arccsc, acsc
        tr
          td Hyperbolic Trig
          td \( \sinh(\lambda) \), &hellip;
          td: code sinh(lambda), &hellip;
          td Also cosh, tanh, coth, sech, csch
        tr
          td Inv. Hyp. Trig
          td \( \mathrm{arcsinh}(x) \), &hellip;
          td: code arcsinh(x), asinh(x), &hellip;
          td Also arccosh, acosh, arctanh, atanh, arccoth, acoth, arcsech, asech, arccsch, acsch
        tr
          td Absolute Value
          td \( \left| a \right| \)
          td: code abs(a)
          td May be expressed with "pipe" delimiters.
        tr
          td Floor
          td \( \left\lfloor x \right\rfloor \)
          td: code floor(x)
          td
        tr
          td Ceiling
          td \( \left\lceil x \right\rceil \)
          td: code ceil(x), ceiling(x)
          td
        tr
          td Square Root
          td \( \sqrt{a} \)
          td: code sqrt(a)
          td
        tr
          td \(n\)th Root
          td \( \sqrt[n]{a} \)
          td: code root(a, n)
          td
        tr
          td Natural Exponential
          td \( \exp(a) \)
          td: code exp(a)
          td
        tr
          td Natural Logarithm
          td \( \ln(a) \)
          td: code ln(a)
          td
        tr
          td Logarithm with Base
          td \( \log_b{a} \)
          td: code log(a, b)
          td
        tr
          td Combination
          td \( \binom{n}{r} \)
          td: code C(n,r), combination(n,r), comb(n,r)
          td Binomial Coefficient, choose
        tr
          td Permutation
          td \( P(n,r) \)
          td: code P(n,r), permutation(n,r), perm(n,r)
          td
        tr
          td Limit
          td \( \displaystyle\lim_{x\to a} f(x) \)
          td: code lim(f(x), a, x), limit(f(x), x, a), &amp;lim &amp;_(x -&gt; a) f(x)
          td Also <tt>limit</tt>, <tt>Lim</tt>, <tt>Limit</tt>, &hellip;
        tr
          td Derivative
          td \( \displaystyle \frac{\mathrm{d}}{\mathrm{d}x} \left( f(x) \right) \)
          td: code diff(f(x), x), &amp;df(x)/&amp;dx
          td
        tr
          td Partial Derivative
          td \( \displaystyle \frac{\partial}{\partial x} \left( f(x,y) \right) \)
          td: code pdiff(f(x,y), x), &amp;pdf(x)/&amp;pdx
          td
        tr
          td Indefinite Integral
          td \( \displaystyle \int f(x) \,\mathrm{d}x \)
          td: code int(f(x),x), &amp;int f(x) &amp;dx
          td Also <tt>Int</tt>, <tt>integral</tt>, <tt>Integral</tt>, &hellip;
        tr
          td Definite Integral
          td \( \displaystyle \int_a^b f(x) \,\mathrm{d}x \)
          td: code int(f(x),x,a,b), &amp;int &amp;_a &amp;^b f(x) &amp;dx
          td (see note above)
        tr
          td Sum Over Range
          td \( \displaystyle \sum_{i=m}^n a_i \)
          td: code sum(a&amp;_i,i,m,n), &amp;sum &amp;_(i=m) &amp;^n a&amp;_i
          td Also <tt>Sum</tt>
        tr
          td Sum Over Set
          td \( \displaystyle \sum_{i \in S} a_i \)
          td: code sum(a&amp;_i, i in S), &amp;sum &amp;_(i in S) a&amp;_i
          td (see note above)
        tr
          td Product Over Range
          td \( \displaystyle \prod_{i=m}^n a_i \)
          td: code prod(a&amp;_i,m,n), product(a&amp;_i,m,n), &amp;prod &amp;_(i=m) &amp;^n a&amp;_i
          td Also <tt>product</tt>, <tt>Prod</tt>, <tt>Product</tt>, &hellip;
        tr
          td Product Over Set
          td \( \displaystyle \prod_{i \in S} a_i \)
          td: code prod(a&amp;_i, i in S), product(a&amp;_i, i in S), &amp;prod &amp;_(i in S) a&amp;_i
          td (see note above)
        tr
          td Union Over Range
          td \( \displaystyle \bigcup_{i=m}^n S_i \)
          td: code Union(S&amp;_i,m,n), &amp;Union &amp;_(i=m) &amp;^n S&amp;_i
          td
        tr
          td Union Over Set
          td \( \displaystyle \bigcup_{i \in T} S_i \)
          td: code Union(S&amp;_i, i in T), &amp;Union &amp;_(i in T) S&amp;_i
          td
        tr
          td Intersection Over Range
          td \( \displaystyle \bigcap_{i=m}^n S_i \)
          td: code Intersect(S&amp;_i,m,n), &amp;Intersect &amp;_(i=m) &amp;^n S&amp;_i
          td
        tr
          td Intersection Over Set
          td \( \displaystyle \bigcap_{i \in T} S_i \)
          td: code Intersect(S&amp;_i, i in T), &amp;Intersect &amp;_(i in T) S&amp;_i
          td

  section#by-topic
    h2 Symbols by Topic

    p.
      Repetition can lead to discrepancy, and this section is already quite repetetive. Please refer to the tables above
      for precedence and associativity information. These tables are provided merely for convenience when attempting to
      find a particular token. Hence it is redundant to provide extra information.

    h3#arithmetic Arithmetic
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Plus, Positive
          td \( + \)
          td: code +
          td binary or unary
        tr
          td Minus, Negative
          td \( - \)
          td: code -
          td binary or unary
        tr
          td Plus/Minus
          td \( \pm \)
          td: code +/-, &amp;pm
          td binary or unary
        tr
          td Minus/Plus
          td \( \mp \)
          td: code -/+, &amp;mp
          td binary or unary
        tr
          td Times
          td \( \cdot \)
          td: code *
          td Multiplication
        tr
          td Divided by
          td \( \frac{a}{b} \), \( a/b \)
          td: code a/b, a &amp;/ b
          td Division
        tr
          td Power
          td \( a^b \)
          td: code a^b, a**b
          td Exponentiation
        tr
          td Square Root
          td \( \sqrt{a} \)
          td: code sqrt(a)
          td
        tr
          td \( n \)-th Root
          td \( \sqrt[n]{a} \)
          td: code root(a, n)
          td
        tr
          td Log base n
          td \( \log_n{a} \)
          td: code log(a, n)
          td
        tr
          td Natural Exponential
          td \( \exp(a) \)
          td: code exp(a)
          td
        tr
          td Natural Logarithm
          td \( \ln(a) \)
          td: code ln(a)
          td
        tr
          td Absolute Value
          td \( \left| a \right| \)
          td: code |a|, |:a:|, abs(a)
          td
        tr
          td Factorial
          td \( n! \)
          td: code a!
          td
        tr
          td Imaginary Unit
          td \( i \)
          td: code #i
          td \( \sqrt{-1} \)
        tr
          td Real Part
          td \( \Re a \)
          td: code &amp;Re a
          td
        tr
          td Imaginary Part
          td \( \Im a \)
          td: code &amp;Im a
          td
        tr
          td Ratio
          td \( a:b \)
          td: code a&amp;:b
          td
        tr
          td Ratio Equality
          td \( a:b :: c:d \)
          td: code a&amp;:b :: c&amp;:d, a&amp;:b as c&amp;:d
          td
        tr
          td Equal
          td \( = \)
          td: code
            | =, ==
          td
        tr
          td Not Equal
          td \( \ne \)
          td: code /=, !=, &lt;&gt;
          td
        tr
          td Less Than
          td \( &lt; \)
          td: code &lt;
          td
        tr
          td Greater Than
          td \( &gt; \)
          td: code &gt;
          td
        tr
          td Less Than or Equal
          td \( \le \)
          td: code &lt;=
          td
        tr
          td Greater Than or Equal
          td \( \ge \)
          td: code &gt;=
          td
        tr
          td Parentheses
          td \( \left( \ \right) \)
          td: code ( )
          td

    h3#algebra Algebra
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Natural Numbers
          td \( \mathbb{N} \)
          td: code #N
          td
        tr
          td Integer Ring
          td \( \mathbb{Z} \)
          td: code #Z
          td
        tr
          td Rational Field
          td \( \mathbb{Q} \)
          td: code #Q
          td
        tr
          td Real Field
          td \( \mathbb{R} \)
          td: code #R
          td
        tr
          td Complex Field
          td \( \mathbb{C} \)
          td: code #C
          td
        tr
          td Function Composition
          td \( f \circ g \)
          td: code f @ g
          td
        tr
          td Function Repeated Composition
          td \( f^{\circ n} \)
          td: code f @@ n
          td
        tr
          td Sum Over Range
          td \( \displaystyle \sum_{i=m}^n a_i \)
          td: code sum(a&amp;_i,i,m,n), &amp;sum &amp;_(i=m) &amp;^n a&amp;_i
          td Also <tt>Sum</tt>
        tr
          td Sum Over Set
          td \( \displaystyle \sum_{i \in S} a_i \)
          td: code sum(a&amp;_i, i in S), &amp;sum &amp;_(i in S) a&amp;_i
          td (see note above)
        tr
          td Product Over Range
          td \( \displaystyle \prod_{i=m}^n a_i \)
          td: code prod(a&amp;_i,m,n), product(a&amp;_i,m,n), &amp;prod &amp;_(i=m) &amp;^n a&amp;_i
          td Also <tt>product</tt>, <tt>Prod</tt>, <tt>Product</tt>
        tr
          td Product Over Set
          td \( \displaystyle \prod_{i \in S} a_i \)
          td: code prod(a&amp;_i, i in S), product(a&amp;_i, i in S), &amp;prod &amp;_(i in S) a&amp;_i
          td (see note above)

    h3#geometry Geometry
    table
      thead
        tr
          td Name
          td Symbol
          td Code
          td Description
      tbody
        tr
          td Pi
          td \( \pi \)
          td: code #pi, #p
          td 3.14&hellip;
        tr
          td Tau
          td \( \tau \)
          td: code #tau
          td \( 2 \pi \) &asymp; 6.28&hellip;
        tr
          td Open Interval
          td \( \left( a,b \right) \)
          td: code (:a,b:)
          td Exclusive Range Delimiters
        tr
          td Closed Interval
          td \( \left[ a,b \right] \)
          td: code [:a,b:]
          td Inclusive Range Delimiters
        tr
          td Half-Open Interval
          td \( \left[ a,b \right) \)
          td: code [:a,b:)
          td Mixed Range Delimiters
        tr
          td Congruent
          td \( \cong \)
          td: code ~=, congruent
          td
        tr
          td Similar
          td \( \sim \)
          td: code ~, sim, similar
          td
        tr
          td Parallel
          td \( \parallel \)
          td: code para, parallel
          td
        tr
          td Perpendicular
          td \( \perp \)
          td: code perp, perpendicular
          td
        tr
          td Vector Components
          td \( \left\langle a, b, c \right\rangle \)
          td: code &lt; a, b, c &gt;, &lt;: a, b, c :&gt;
          td
        tr
          td Vector
          td \( \vec{a} \)
          td: code &amp;v a
          td
        tr
          td Unit Vector
          td \( \hat{a} \)
          td: code &amp;u a
          td
        tr
          td(rowspan=2) Vector Length
          td \( \left| \vec{a} \right| \)
          td: code | &amp;v a |, |: &amp;v a :|
          td
        tr
          td \( \left\| \vec{a} \right\| \)
          td: code || &amp;v a ||, ||: &amp;v a :||
          td
        tr
          td Zero Vector
          td \( \vec{0} \)
          td: code #v0
          td
        tr
          td \( x \) Unit Vector
          td \( \hat{\imath} \)
          td: code #ui, #vi
          td
        tr
          td \( y \) Unit Vector
          td \( \hat{\jmath} \)
          td: code #uj, #vj
          td
        tr
          td \( z \) Unit Vector
          td \( \hat{k} \)
          td: code #uk, #vk
          td
        tr
          td Dot Product
          td \( \vec{a} \cdot \vec{b} \)
          td: code &amp;v a &amp;. &amp;v b
          td
        tr
          td Cross Product
          td \( \vec{a} \times \vec{b} \)
          td: code &amp;v a &amp;x &amp;v b
          td

    h3#trigonometry Trigonometry
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Trig
          td \( \sin(\theta) \), &hellip;
          td: code sin(theta), &hellip;
          td Also cos, tan, cot, sec, csc
        tr
          td Inverse Trig
          td \( \arcsin(x) \), &hellip;
          td: code arcsin(x), asin(x), &hellip;
          td Also arccos, acos, arctan, atan, arccot, acot, arcsec, asec, arccsc, acsc
        tr
          td Hyperbolic Trig
          td \( \sinh(\lambda) \), &hellip;
          td: code sinh(lambda), &hellip;
          td Also cosh, tanh, coth, sech, csch
        tr
          td Inv. Hyp. Trig
          td \( \mathrm{arcsinh}(x) \), &hellip;
          td: code arcsinh(x), asinh(x), &hellip;
          td Also arccosh, acosh, arctanh, atanh, arccoth, acoth, arcsech, asech, arccsch, acsch

    h3#discrete Discrete
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Natural Numbers
          td \( \mathbb{N} \)
          td: code #N
          td
        tr
          td Integer Ring
          td \( \mathbb{Z} \)
          td: code #Z
          td
        tr
          td Factorial
          td \( n! \)
          td: code a!
          td
        tr
          td Floor
          td \( \left\lfloor x \right\rfloor \)
          td: code floor(x)
        tr
          td Ceiling
          td \( \left\lceil x \right\rceil \)
          td: code ceil(x), ceiling(x)
          td
        tr
          td Modulus
          td \( a \pmod{n} \)
          td: code a%n, a mod n
          td
        tr
          td Divides
          td \( p \mid q \)
          td: code p|q, p divides q
          td
        tr
          td Not Divides
          td \( p \nmid q \)
          td: code p/|q, p~|q, p ndivides q, p ndivide q, p notdivides q, p notdivide q
          td
        tr
          td Combination
          td \( \binom{n}{r} \)
          td: code C(n,r)
          td Binomial Coefficient; Choose
        tr
          td Permutation
          td \( P(n,r) \)
          td: code P(n,r)
          td
        tr
          td Sum Over Range
          td \( \displaystyle \sum_{i=m}^n a_i \)
          td: code sum(a&amp;_i,i,m,n), &amp;sum &amp;_(i=m) &amp;^n a&amp;_i
          td Also <tt>Sum</tt>
        tr
          td Sum Over Set
          td \( \displaystyle \sum_{i \in S} a_i \)
          td: code sum(a&amp;_i, i in S), &amp;sum &amp;_(i in S) a&amp;_i
          td (see note above)
        tr
          td Product Over Range
          td \( \displaystyle \prod_{i=m}^n a_i \)
          td: code prod(a&amp;_i,m,n), product(a&amp;_i,m,n), &amp;prod &amp;_(i=m) &amp;^n a&amp;_i
          td Also <tt>product</tt>, <tt>Prod</tt>, <tt>Product</tt>
        tr
          td Product Over Set
          td \( \displaystyle \prod_{i \in S} a_i \)
          td: code prod(a&amp;_i, i in S), product(a&amp;_i, i in S), &amp;prod &amp;_(i in S) a&amp;_i
          td (see note above)
        tr
          td Union Over Range
          td \( \displaystyle \bigcup_{i=m}^n S_i \)
          td: code Union(S&amp;_i,m,n), &amp;Union &amp;_(i=m) &amp;^n S&amp;_i
          td
        tr
          td Union Over Set
          td \( \displaystyle \bigcup_{i \in T} S_i \)
          td: code Union(S&amp;_i, i in T), &amp;Union &amp;_(i in T) S&amp;_i
          td
        tr
          td Intersection Over Range
          td \( \displaystyle \bigcap_{i=m}^n S_i \)
          td: code Intersect(S&amp;_i,m,n), &amp;Intersect &amp;_(i=m) &amp;^n S&amp;_i
          td
        tr
          td Intersection Over Set
          td \( \displaystyle \bigcap_{i \in T} S_i \)
          td: code Intersect(S&amp;_i, i in T), &amp;Intersect &amp;_(i in T) S&amp;_i
          td

    h3#calculus Calculus
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Pi
          td \( \pi \)
          td: code #pi, #p
          td 3.14&hellip;
        tr
          td Tau
          td \( \tau \)
          td: code #tau
          td \( 2 \pi \) &asymp; 6.28&hellip;
        tr
          td E
          td \( \mathrm{e} \)
          td: code #e
          td 2.718&hellip;, Natural Base, Euler-Napier number
        tr
          td gamma
          td \( \gamma \)
          td: code #gamma
          td 0.577&hellip;, Euler-Mascheroni constant
        tr
          td infinity
          td \( \infty \)
          td: code #infinity, infinity
          td \( \infty \) &asymp; <span class="error">#!ERROR: memory overflow</span>
        tr
          td Limit
          td \( \displaystyle\lim_{x\to a} f(x) \)
          td: code lim(f(x), a, x), limit(f(x), x, a), &amp;lim &amp;_(x -&gt; a) f(x)
          td Also <tt>limit</tt>, <tt>Lim</tt>, <tt>Limit</tt>
        tr
          td Derivative
          td \( \displaystyle \frac{\mathrm{d}}{\mathrm{d}x} \left( f(x) \right) \)
          td: code diff(f(x), x), &amp;df(x)/&amp;dx
          td
        tr
          td Partial Derivative
          td \( \displaystyle \frac{\partial}{\partial x} \left( f(x,y) \right) \)
          td: code pdiff(f(x,y), x), &amp;pdf(x)/&amp;pdx
          td
        tr
          td Prime derivative
          td \( f' \)
          td: code f'
          td Derivative w.r.t. \( x \) or first or only variable
        tr
          td Dot derivative
          td \( \dot{f} \)
          td: code f.
          td Derivative w.r.t. \( t \) or second variable
        tr
          td Change
          td \( \Delta x \)
          td: code &amp;D x
          td Coordinate Difference
        tr
          td Differential
          td \( \mathrm{d} x \)
          td: code &amp;d x
          td
        tr
          td Partial Differential
          td \( \partial x \)
          td: code &amp;pd x
          td
        tr
          td Riemann Sum
          td \( \displaystyle \sum_{i=1}^n f(x_i) \, \Delta x_i \)
          td: code sum(f(x&amp;_i)*&amp;Dx&amp;_i, i, 1, n), &amp;sum &amp;_(i=1) &amp;^n F(x&amp;_i)*&amp;Dx&amp;_i
          td Also <tt>Sum</tt>
        tr
          td Indefinite Integral
          td \( \displaystyle \int f(x) \,\mathrm{d}x \)
          td: code int(f(x),x), &amp;int f(x) &amp;dx
          td Also <tt>Int</tt>, <tt>integral</tt>, <tt>Integral</tt>
        tr
          td Definite Integral
          td \( \displaystyle \int_a^b f(x) \,\mathrm{d}x \)
          td: code int(f(x),x,a,b), &amp;int &amp;_a &amp;^b f(x) &amp;dx
          td (see note above)
        tr
          td Infinite Series
          td \( \displaystyle \sum_{i=1}^\infty a_i \)
          td: code sum(a&amp;_i, i, 1, infinity), &amp;sum &amp;_(i=1) &amp;^infinity a&amp;_i
          td (see note above)
        tr
          td Gradient
          td \( \vec{\nabla} f \), \( \mathrm{grad}(f) \)
          td: code &amp;del f, grad(f)
          td
        tr
          td Divergence
          td \( \vec{\nabla} \cdot F \), \( \mathrm{div}(F) \)
          td: code &amp;del. F, div(F)
          td
        tr
          td Curl
          td \( \vec{\nabla} \times F \), \( \mathrm{curl}(F) \)
          td: code &amp;delx F, curl(F)
          td

    h3#logic Logic
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td True
          td \( \mathbf{T} \)
          td: code #T, #true, true
          td Case-insensitive
        tr
          td False
          td \( \mathbf{F} \)
          td: code #F, #false, false
          td Case-insensitive
        tr
          td And
          td \( p \wedge q \)
          td: code p &amp;&amp; q, p and q
          td Conjugation
        tr
          td Or
          td \( p \vee q \)
          td: code p || q, p or q
          td Disjunction
        tr
          td Exclusive Or
          td \( p \veebar q \)
          td: code p xor q
          td Exclusion
        tr
          td Not
          td \( \neg p \)
          td: code ~p, !p, not p
        tr
          td Implies
          td \( p \rightarrow q \)
          td: code p -&gt; q, p implies q, p onlyif q, if p then q
          td Conditional
        tr
          td Implied By
          td \( p \leftarrow q \)
          td: code p &lt;- q, p imqliedby q, p if q, p when q, p whenever q
          td Reverse Conditional
        tr
          td If And Only If
          td \( p \leftrightarrow q \)
          td: code p &lt;-&gt; q, p iff q
          td Biconditional
        tr
          td Equivalent
          td \( \equiv \)
          td: code
            | ===, equiv
          td
        tr
          td Not Equivalent
          td \( \not\equiv \)
          td: code !==, /==, nequiv
          td
        tr
          td(rowspan=2) Universal Quantifier
          td \( \forall x \) (we have) \( P(x) \)
          td: code forall x -> P(x)
          td(rowspan=2) "For all &hellip;"
        tr
          td \( \forall x :~Q(x) \) (we have) \( P(x) \)
          td: code forall x : Q(x) -&gt; P(x)
        tr
          td Existential Quantifier
          td \( \exists x :~Q(x) \)
          td: code exists x : Q(x)
          td "There exists &hellip; such that &hellip;"
        tr
          td Unique Quantifier
          td \( \exists ! x :~Q(x) \)
          td: code unique x : Q(x)
          td "There exists a unique &hellip; such that &hellip;"

    h3#set-theory Set Theory
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Set Delimiters
          td \( \left\{ \ \right\} \)
          td: code { }
          td
        tr
          td Such That
          td \( p : q \)
          td: code p:q
          td Used with set builder and quantifiers
        tr
          td Universal Set
          td \( \mathbb{U} \)
          td: code #U
          td
        tr
          td Empty Set
          td \( \emptyset \)
          td: code #empty, {}
          td
        tr
          td Natural Numbers
          td \( \mathbb{N} \)
          td: code #N
          td
        tr
          td Integer Ring
          td \( \mathbb{Z} \)
          td: code #Z
          td
        tr
          td Rational Field
          td \( \mathbb{Q} \)
          td: code #Q
          td
        tr
          td Real Field
          td \( \mathbb{R} \)
          td: code #R
          td
        tr
          td Complex Field
          td \( \mathbb{C} \)
          td: code #C
          td
        tr
          td Quaternion Ring
          td \( \mathbb{H} \)
          td: code #H
          td Hamilton numbers
        tr
          td Octonian Algebra
          td \( \mathbb{O} \)
          td: code #O
          td Cayley numbers, Type "Oh"
        tr
          td Subset
          td \( A \subseteq B \)
          td: code A subset B
          td
        tr
          td Superset
          td \( A \supseteq B \)
          td: code A superset B, A supset B
          td
        tr
          td Proper Subset
          td \( A \subset B \)
          td: code A propersubset B, A propsubset B, A psubset B
          td
        tr
          td Proper Superset
          td \( A \supset B \)
          td: code A propersuperset B, A propsuperset B, A psuperset B, A propersupset B, A propsupset B, A psupset B
          td
        tr
          td Inclusion
          td \( a \in A \)
          td: code a in A
          td
        tr
          td Union
          td \( a \cup b \)
          td: code a union b
          td
        tr
          td Intersection
          td \( a \cap b \)
          td: code a intersect b
          td
        tr
          td Set Difference
          td \( a \setminus b \)
          td: code a \ b, a minus b
          td
        tr
          td Cartesian Product
          td \( A \times B \)
          td: code A &amp;* B, A &amp;x B
          td
        tr
          td Direct Sum
          td \( A \oplus B \)
          td: code A &amp;o+ B
          td
        tr
          td Union Over Range
          td \( \displaystyle \bigcup_{i=m}^n S_i \)
          td: code Union(S&amp;_i,m,n), &amp;Union &amp;_(i=m) &amp;^n S&amp;_i
          td
        tr
          td Union Over Set
          td \( \displaystyle \bigcup_{i \in T} S_i \)
          td: code Union(S&amp;_i, i in T), &amp;Union &amp;_(i in T) S&amp;_i
          td
        tr
          td Intersection Over Range
          td \( \displaystyle \bigcap_{i=m}^n S_i \)
          td: code Intersect(S&amp;_i,m,n), &amp;Intersect &amp;_(i=m) &amp;^n S&amp;_i
          td
        tr
          td Intersection Over Set
          td \( \displaystyle \bigcap_{i \in T} S_i \)
          td: code Intersect(S&amp;_i, i in T), &amp;Intersect &amp;_(i in T) S&amp;_i
          td

    h3#linear-algebra Linear Algebra
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Vector Delimiters
          td \( \left\langle \ \right\rangle \)
          td: code &lt; &gt;, &lt;: :&gt;
          td
        tr
          td Zero Vector
          td \( \vec{0} \)
          td: code #v0
          td
        tr
          td \( x \) Unit Vector
          td \( \hat{\imath} \)
          td: code #ui, #vi
          td
        tr
          td \( y \) Unit Vector
          td \( \hat{\jmath} \)
          td: code #uj, #vj
          td
        tr
          td \( z \) Unit Vector
          td \( \hat{k} \)
          td: code #uk, #vk
          td
        tr
          td(rowspan=2) Matrix Delimiters
          td \( \left[ \left\langle \ \right\rangle, \left\langle \ \right\rangle \right] \)
          td: code [ &lt; &gt;, &lt; &gt; ]
          td Row of Columns
        tr
          td \( \left\langle \left[ \ \right], \left[ \ \right] \right\rangle \)
          td: code &lt; [ ], [ ] &gt;
          td Column of Rows
        tr
          td Zero Matrix
          td \( \mathbf{0} \)
          td: code #0
          td Type "zero"
        tr
          td Unit Matrix
          td \( \mathbf{I} \)
          td: code #1
          td Identity Matrix, Type "one"

block javascripts
    script(src='http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML')

