extends layout

block append vars
  next_page = {href: 'how-mathlex-works.html', title: 'How MathLex Works'}

block article
  h1 Language Specification

  p.
    This section describes the syntax used to enter mathematical content into MathLex. For clarity, this information is
    presented in two ways: the first is organized by how the symbol is used in the language (e.g. binary operators,
    relations, etc.); the second is organized by the topic (e.g.  calculus, set theory, etc.). This page is meant to be
    a non-technical reference for the end-user (i.e. student) typing MathLex input.


  h2 Section Contents
  nav.toc
    ul
      li: a(href='#summary') Summary
        ul
          li: a(href='#numbers') Numbers
          li: a(href='#identifiers') Identifiers
          li: a(href='#constants') Constants
          li: a(href='#operators') Operators
      li: a(href='#by-type') Symbols by Type
        ul
          li: a(href='#constants') Constants
          li: a(href='#unary') Unary Operators
          li: a(href='#binary') Binary Operators
          li: a(href='#relations') Relations
          li: a(href='#delimiters') Delimiters
          li: a(href='#functions') Functions
      li: a(href='#by-topic') Symbols by Topic
        ul
          li: a(href='#arithmetic') Arithmetic
          li: a(href='#algebra') Algebra
          li: a(href='#geometry') Geometry
          li: a(href='#trigonometry') Trigonometry
          li: a(href='#discrete') Discrete
          li: a(href='#calculus') Calculus
          li: a(href='#set-theory') Set Theory
          li: a(href='#logic') Logic
          li: a(href='#linear-algebra') Linear Algebra

  h2#summary Summary
  p.
    The basic types of tokens in MathLex are Numbers (further subdivided into Integers and Floats/Decimals),
    Identifiers, Constants, and Operators.

  h3#numbers Numbers
  p.
    A <em>Number</em> is exactly as it seems: <code>42</code>, <code>3.14</code>, etc. Scientific notation is also
    allowed: <code>5e-2</code> <code>3.0E8</code>. In either case, decimal points do not need a leading or trailing
    zero: <code>.5</code>, <code>78.</code>, <code>9.E-4</code>, <code>.22e7</code>.

    Note that negative numbers are treated as a negation operation on the positive value of the number (in continuity
    with algebraic notation).  Likewise, fractions are treated as division on whole numbers.

  h3#identifiers Identifiers
  p.
    An <em>Identifier</em> is an upper- or lowercase letter followed by any number of upper- or lowercase letters,
    numbers, or underscores (<code>_</code>). All of the following are valid identifiers: <code>x</code>,
    <code>A</code>, <code>b0</code>, <code>my_var</code> Identifiers fall under two categories: reserved keywords and
    variables. Reserved keywords are listed in the tables below, and all other identifiers are treated as variables.
    Since none of the example identifiers are reserved keywords, they also qualify as valid variable names.

  h3#constants Constants
  p.
    Similar to identifiers, <em>Constants</em> are globally defined values or constructs. In MathLex, constants are
    typed as a number sign (<code>#</code>; also called <em>hash</em> or <em>pound</em>) followed by the name of the
    constant. For example, in Mathlex, one would type <code>#pi</code> (or <code>#p</code> for short) to represent "pi"
    (\( \pi \)) and <code>#R</code> to represent the set of real numbers (\( \mathbb{R} \)). See the table of
    <a href="#constants">Constants</a> below for a comprehensive list.

  h3#operators Operators
  p.
    <em>Operators</em> is just a catch-all term for any symbol that is not a Number, Identifier, or Constant, but is
    generally a mathematical operation or delimiter. With the exception of a few reserved keywords, operators usually
    consist of a few non-alphanumeric characters. Some operators start with an ampersand to distinguish them from
    similar symbols Some mathematical operators can be represented in multiple ways in MathLex. The tables below outline
    all mathematical operators understood by MathLex and all ways to represent them. Pick your favorite.

  p.
    The values in the <em>Precedence</em> column of operator tables reflect which operations are more tightly bound
    (e.g. the "<abbr title="Parentheses, Exponents, Multiplication, Division, Addition, Subtraction">PEMDAS</abbr>"
    order of operations from grade school mathematics). Operators of higher precedence (greater numerical value) will be
    identified and grouped before operators with lower precedence (lesser numerical value). Operators of equal
    precedence will be grouped as they are found according to their associativity.

  p.
    <em>Associativity</em> describes how chained operations would be bound together.

  ul
    li.
      Left-associative operators will be grouped from left to right (like addition and subtraction):
      <code>a + b + c + d = ((a + b) + c) + d</code>
    li.
      Right-associative operators will be grouped from right to left (like exponents):
      <code>a ^ b ^ c ^ d = a ^ (b ^ (c ^ d))</code>
    li.
      Non-associative operators cannot be chained. For example, the triple dot product <code>a &. b &. c</code> doesn't
      make any sense since the result of a dot product is a scalar. At present, MathLex does not allow chaining of
      <a href="#relations">relations</a>.

  section#by-type
    h2 Symbols by Type

    h3#constants Constants
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Pi
          td \( \pi \)
          td: code #pi, #p
          td 3.14&hellip;
        tr
          td Tau
          td \( \tau \)
          td: code #tau, #t
          td \( 2 \pi \) &asymp; 6.28&hellip;
        tr
          td E
          td \( \mathrm{e} \)
          td: code #e
          td 2.718&hellip;, Natural Base, Euler-Napier number
        tr
          td Gamma
          td \( \gamma \)
          td: code #gamma
          td 0.577&hellip;, Euler-Mascheroni constant
        tr
          td Infinity
          td \( \infty \)
          td: code #infinity, infinity
          td: code.error ERROR: memory overflow
        tr
          td Imaginary Unit
          td \( i \)
          td: code #i
          td \( \sqrt{-1} \)
        tr
          td True
          td \( \mathbf{T} \)
          td: code #T, #true, true
          td
        tr
          td False
          td \( \mathbf{F} \)
          td: code #F, #false, false
          td
        tr
          td Natural Numbers
          td \( \mathbb{N} \)
          td: code #N
          td
        tr
          td Integer Ring
          td \( \mathbb{Z} \)
          td: code #Z
          td
        tr
          td Rational Field
          td \( \mathbb{Q} \)
          td: code #Q
          td
        tr
          td Real Field
          td \( \mathbb{R} \)
          td: code #R
          td
        tr
          td Complex Field
          td \( \mathbb{C} \)
          td: code #C
          td
        tr
          td Quaternion Ring
          td \( \mathbb{H} \)
          td: code #H
          td Hamilton numbers
        tr
          td Octonian Algebra
          td \( \mathbb{O} \)
          td: code #O
          td Cayley numbers, Type "Oh"
        tr
          td Universal Set
          td \( \mathbb{U} \)
          td: code #U
          td
        tr
          td Empty Set
          td \( \emptyset \)
          td: code #empty, {}
          td
        tr
          td Zero Vector
          td \( \vec{0} \)
          td: code #v0
          td
        tr
          td \( x \) Unit Vector
          td \( \hat{\imath} \)
          td: code #ui, #vi
          td
        tr
          td \( y \) Unit Vector
          td \( \hat{\jmath} \)
          td: code #uj, #vj
          td
        tr
          td \( z \) Unit Vector
          td \( \hat{k} \)
          td: code #uk, #vk
          td
        tr
          td Zero Matrix
          td \( \mathbf{0} \)
          td: code #0
          td Type "zero"
        tr
          td Unit Matrix
          td \( \mathbf{I} \)
          td: code #1
          td Identity Matrix, Type "one"

    h3#unary Unary Operators
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
          th Precedence
      tbody
        tr
          td Positive
          td \( +a \)
          td: code +a
          td
          td.center 17
        tr
          td Negative
          td \( -a \)
          td: code -a
          td
          td.center 17
        tr
          td Positive/Negative
          td \( \pm a \)
          td: code +/-a, &amp;pm a
          td
          td.center 17
        tr
          td Negative/Positive
          td \( \mp a \)
          td: code &amp;mp a, -/+a
          td
          td.center 17
        tr
          td Square Root
          td \( \sqrt{a} \)
          td: code sqrt(a)
          td
          td.center *
        tr
          td Factorial
          td \( n! \)
          td: code a!
          td
          td.center 21
        tr
          td Natural Exponential
          td \( \exp(a) \)
          td: code exp(a)
          td
          td.center *
        tr
          td Natural Logarithm
          td \( \ln(a) \)
          td: code ln(a)
          td
          td.center *
        tr
          td Not
          td \( \neg p \)
          td: code not p, ~p, !p
          td Logical Negation
          td.center 17
        tr
          td Prime derivative
          td \( f' \)
          td: code f'
          td Derivative w.r.t. \( x \) or first or only variable
          td.center 21
        tr
          td Dot derivative
          td \( \dot{f} \)
          td: code f.
          td Derivative w.r.t. \( t \) or second variable
          td.center 21
        tr
          td Change
          td \( \Delta x \)
          td: code &amp;D x
          td Coordinate Difference
          td.center 17
        tr
          td Differential
          td \( \mathrm{d} x \)
          td: code &amp;d x
          td
          td.center 17
        tr
          td Partial Differential
          td \( \partial x \)
          td: code &amp;pd x
          td
          td.center 17
        tr
          td Vector
          td \( \vec{a} \)
          td: code &amp;v a
          td
          td.center 17
        tr
          td Unit Vector
          td \( \hat{a} \)
          td: code &amp;u a
          td
          td.center 17
        tr
          td Gradient
          td \( \vec{\nabla} f \), \( \mathrm{grad}(f) \)
          td: code &amp;del f, grad(f)
          td
          td.center 17
        tr
          td Divergence
          td \( \vec{\nabla} \cdot F \), \( \mathrm{div}(F) \)
          td: code &amp;del. F, div(F)
          td
          td.center 17
        tr
          td Curl
          td \( \vec{\nabla} \times F \), \( \mathrm{curl}(F) \)
          td: code &amp;delx F, curl(F)
          td
          td.center 17

    p.
      Note that all prefix operators are <strong>right-associative</strong> and all postfix operators are
      <strong>left-associative</strong>.

    p.
      * Although not listed, a pair of parentheses, when used as a function application, may be considered a postfix
      unary operator. As such, it is <strong>left-associative</strong> and has a precedence of <strong>18</strong>, just
      below that of function composition and exponents.

    h3#binary Binary Operators
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
          th Precedence
          th Associativity
      tbody
        tr
          td Plus
          td \( a + b \)
          td: code a + b
          td Addition
          td.center 9
          td.center Left
        tr
          td Minus
          td \( a - b \)
          td: code a - b
          td Subtraction
          td.center 9
          td.center Left
        tr
          td Plus/Minus
          td \( a \pm b \)
          td: code a +/- b, a &amp;pm b
          td
          td.center 9
          td.center Left
        tr
          td Minus/Plus
          td \( a \mp b \)
          td: code a -/+ b, a &amp;mp b
          td
          td.center 9
          td.center Left
        tr
          td Times
          td \( a \cdot b \)
          td: code a * b
          td Multiplication
          td.center 14
          td.center Left
        tr
          td Divided by
          td \( \frac{a}{b} \), \( a/b \)
          td: code a/b, a &amp;/ b
          td Division
          td.center 14
          td.center Left
        tr
          td Power
          td \( a^b \)
          td: code a^b, a**b
          td Exponentiation
          td.center 20
          td.center Right
        tr
          td \( n \)-th Root
          td \( \sqrt[n]{a} \)
          td: code root(a, n)
          td
          td
          td
        tr
          td Logarithm with Base
          td \( \log_b{a} \)
          td: code log(a, b)
          td
          td
          td
        tr
          td Ratio
          td \( p : q \)
          td: code p&amp;:q
          td
          td.center 8
          td.center Non
        tr
          td Modulus
          td \( a \pmod{n} \)
          td: code a%n, a mod n
          td
          td.center 14
          td.center Left
        tr
          td Combination
          td \( \binom{n}{r} \)
          td: code C(n,r)
          td Binomial Coefficient; choose
          td
          td
        tr
          td Permutation
          td \( P(n,r) \)
          td: code P(n,r)
          td
          td
          td
        tr
          td Function Composition
          td \( f \circ g \)
          td: code f @ g
          td
          td.center 19
          td.center Left
        tr
          td Function Repeated Composition
          td \( f^{\circ n} \)
          td: code f @@ n
          td not implemented
          td.center 20
          td.center Right
        tr
          td Dot Product
          td \( \vec{a} \cdot \vec{b} \)
          td: code &amp;v a &amp;. &amp;v b
          td
          td.center 15
          td.center Non
        tr
          td Cross Product
          td \( \vec{a} \times \vec{b} \)
          td: code &amp;v a &amp;x &amp;v b
          td
          td.center 16
          td.center Left
        tr
          td Wedge Product
          td \( \vec{a} \wedge \vec{b} \)
          td: code &amp;v a &amp;w &amp;v b
          td
          td.center 16
          td.center Left
        tr
          td Tensor Product
          td \( T \otimes S \)
          td: code T &amp;ox S
          td
          td.center 16
          td.center Left
        tr
          td Cartesian Product
          td \( A \times B \)
          td: code A &amp;* B, A &amp;x B
          td
          td.center 16
          td.center Left
        tr
          td Direct Sum
          td \( A \oplus B \)
          td: code A &amp;o+ B
          td
          td.center 11
          td.center Left
        tr
          td Subscript
          td \( a_b \)
          td: code a&amp;_b
          td(rowspan=2) Indexing
          td.center(rowspan=2) 22
          td.center(rowspan=2) Left
        tr
          td Multiple Subscript
          td \( a_{i,j,k} \)
          td: code a &amp;_[i,j,k]
        tr
          td Superscript
          td \( a^b \)
          td: code a&amp;^b
          td(rowspan=2) Indexing
          td.center(rowspan=2) 22
          td.center(rowspan=2) Left
        tr
          td Multiple Superscript
          td \( a^{i,j,k} \)
          td: code a &amp;^[i,j,k]
        tr
          td Mixed Subscripts and Superscripts
          td \( T{}^i{}_j{}^k \)
          td: code T &amp;^i &amp;_j &amp;^k
          td Tensor Indexing
          td
          td
        tr
          td Union
          td \( a \cup b \)
          td: code a union b
          td
          td.center 12
          td.center Left
        tr
          td Intersection
          td \( a \cap b \)
          td: code a intersect b
          td
          td.center 13
          td.center Left
        tr
          td Set Difference
          td \( a \setminus b \)
          td: code a \ b, a minus b
          td
          td.center 10
          td.center Left
        tr
          td Such That
          td \( p : q \)
          td: code p:q
          td Used with set builder and quantifiers
          td
          td
        tr
          td And
          td \( p \wedge q \)
          td: code p &amp;&amp; q, p and q
          td Conjugation
          td.center 5
          td.center Left
        tr
          td Or
          td \( p \vee q \)
          td: code p || q, p or q
          td Disjunction
          td.center 3
          td.center Left
        tr
          td Exclusive Or
          td \( p \veebar q \)
          td: code p xor q
          td Exclusion
          td.center 4
          td.center Left
        tr
          td Implies
          td \( p \rightarrow q \)
          td: code p -&gt; q, p implies q, p onlyif q, if p then q
          td Conditional
          td.center 2
          td.center Left
        tr
          td Implied By
          td \( p \leftarrow q \)
          td: code p &lt;- q, p imqliedby q, p if q, p when q, p whenever q
          td Reverse Conditional
          td.center 2
          td.center Left
        tr
          td If And Only If
          td \( p \leftrightarrow q \)
          td: code p &lt;-&gt; q, p iff q
          td Biconditional
          td.center 1
          td.center Non
        tr
          td(rowspan=2) Universal Quantifier
          td \( \forall x \) (we have) \( P(x) \)
          td: code forall x -> P(x)
          td(rowspan=2) "For all &hellip;"
          td.center(rowspan=2) 6
          td.center(rowspan=2) Left
        tr
          td \( \forall x :~Q(x) \) (we have) \( P(x) \)
          td: code forall x : Q(x) -&gt; P(x)
        tr
          td Existential Quantifier
          td \( \exists x :~Q(x) \)
          td: code exists x : Q(x)
          td "There exists &hellip; such that &hellip;"
          td.center 6
          td.center Left
        tr
          td Unique Quantifier
          td \( \exists ! x :~Q(x) \)
          td: code unique x : Q(x)
          td "There exists a unique &hellip; such that &hellip;"
          td.center 6
          td.center Left

    h3#relations Relations
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
          th Precedence
      tbody
        tr
          td Equal
          td \( a = b \)
          td: code
            | a = b, a == b
          td
          td.center 7
        tr
          td Not Equal
          td \( a \ne b \)
          td: code a != b, a /= b, a &lt;&gt; b
          td
          td.center 7
        tr
          td Less Than
          td \( a &lt; b \)
          td: code a &lt; b
          td
          td.center 7
        tr
          td Greater Than
          td \( a &gt; b \)
          td: code a &gt; b
          td
          td.center 7
        tr
          td Less Than or Equal
          td \( a \le b \)
          td: code a &lt;= b
          td
          td.center 7
        tr
          td Greater Than or Equal
          td \( a \ge b \)
          td: code a &gt;= b
          td
          td.center 7
        tr
          td Divides
          td \( p \mid q \)
          td: code p|q, p divides q
          td
          td.center 7
        tr
          td Not Divides
          td \( p \nmid q \)
          td: code p~|q, p/|q, p ndivides q, p ndivide q, p notdivides q, p notdivide q
          td
          td.center 7
        tr
          td Ratio Equality
          td \( a:b :: c:d\)
          td: code a&amp;:b :: c&amp;:d, a&amp;:b as c&amp;:d
          td
          td.center 7
        tr
          td Subset
          td \( A \subseteq B \)
          td: code A subset B
          td
          td.center 7
        tr
          td Superset
          td \( A \supseteq B \)
          td: code A superset B, A supset B
          td
          td.center 7
        tr
          td Proper Subset
          td \( A \subset B \)
          td: code A propersubset B, A propsubset B, A psubset B
          td
          td.center 7
        tr
          td Proper Superset
          td \( A \supset B \)
          td: code A propersuperset B, A propsuperset B, A psuperset B, A propersupset B, A propsupset B, A psupset B
          td
          td.center 7
        tr
          td Inclusion
          td \( a \in A \)
          td: code a in A
          td
          td.center 7
        tr
          td Congruent
          td \( A \cong B \)
          td: code A ~= B, A congruent B
          td
          td.center 7
        tr
          td Similar
          td \( A \sim B \)
          td: code A ~ B, A sim B, A similar B
          td
          td.center 7
        tr
          td Parallel
          td \( A \parallel B \)
          td: code A para B, A parallel B
          td
          td.center 7
        tr
          td Perpendicular
          td \( A \perp B \)
          td: code A perp B, A perpendicular B
          td
          td.center 7
        tr
          td Equivalent
          td \( A \equiv B \)
          td: code
            | A === B, A equiv B
          td
          td.center 0
        tr
          td Not Equivalent
          td \( A \not\equiv B \)
          td: code A !== B, A /== B, A nequiv B
          td
          td.center 0

    p.
      As previously stated, all relations are <strong>non-associative</strong> since <code>a = b = c = d</code> is
      <em>NOT</em> the same as <code>((a = b) = c) = d</code> or <code>a = (b = (c = d))</code>. Later versions of
      MathLex may support such expressions as <code>a = b = c = d</code> to be "syntactic sugar" for <code>(a = b) and
      (b = c) and (c = d)</code>

    h3#delimiters Delimiters and Indexing
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Parentheses
          td \( \left( \ \right) \)
          td: code ( )
          td Order of operation
        tr
          td Curly Braces
          td \( \left\{ \ \right\} \)
          td: code { }
          td Sets
        tr
          td Square Brackets
          td \( \left[ \ \right] \)
          td: code [ ]
          td Lists
        tr
          td Angle Brackets
          td \( \left\langle \ \right\rangle \)
          td: code &lt; &gt;, &lt;: :&gt;
          td Vectors
        tr
          td(rowspan=2) Matrix
          td \( \left[ \left\langle \ \right\rangle, \left\langle \ \right\rangle \right] \)
          td: code [&lt; &gt;, &lt; &gt;], [&lt;: :&gt;, &lt;: :&gt;]
          td Row of Columns
        tr
          td \( \left\langle \left[ \right], \left[ \right] \right\rangle \)
          td: code [&lt; &gt;, &lt; &gt;], [&lt;: :&gt;, &lt;: :&gt;]
          td Column of Rows
        tr
          td Vertical Bars
          td \( \left| \ \right| \)
          td: code | |, |: :|
          td Absolute Value, Length, Determinant, Norm
        tr
          td Double Bars
          td \( \left\| \ \right\| \)
          td: code || ||, ||: :||
          td Length, Norm
        tr
          td Floor
          td \( \left\lfloor x \right\rfloor \)
          td: code floor(x)
        tr
          td Ceiling
          td \( \left\lceil x \right\rceil \)
          td: code ceil(x), ceiling(x)
          td
        tr
          td Such That
          td \( p : q \)
          td: code p:q
          td Used with set builder and quantifiers
        tr
          td List Separator
          td \( , \)
          td: code ,
          td
        tr
          td Subscript
          td \( a_b \)
          td: code a &amp;_b
          td(rowspan=2) Indexing
        tr
          td Multiple Subscript
          td \( a_{i,j,k} \)
          td: code a &amp;_[i,j,k]
        tr
          td Superscript
          td \( a^b \)
          td: code a &amp;^b
          td(rowspan=2) Indexing
        tr
          td Multiple Superscript
          td \( a^{i,j,k} \)
          td: code a &amp;^[i,j,k]
        tr
          td Mixed Subscripts and Superscripts
          td \( T{}^i{}_j{}^k \)
          td: code T &amp;^i &amp;_j &amp;^k
          td Tensor Indexing
        tr
          td Open Interval
          td \( \left( a,b \right) \)
          td: code (:a,b:)
          td Exclusive Range Delimiters
        tr
          td Closed Interval
          td \( \left[ a,b \right] \)
          td: code [:a,b:]
          td Inclusive Range Delimiters
        tr
          td Half-Open Interval
          td \( \left[ a,b \right) \)
          td: code [:a,b:)
          td Mixed Range Delimiters
        tr
          td Bra-Ket Notation
          td \( \left\langle A \mid B \right\rangle \)
          td: code &lt;A||B&gt;, &lt;:A|B:&gt;
          td
        tr
          td Bra
          td \( \left\langle A \right| \)
          td: code &lt;A|
          td
        tr
          td Ket
          td \( \left| B \right\rangle \)
          td: code |B&gt;
          td

    p.
      Note that some delimiters have more than one format either with or without colons. Namely, absolute value can be
      written as <code>| &hellip; |</code> or <code>|: &hellip; :|</code>, norm can be written as <code>|| &hellip;
      ||</code> or <code>||: &hellip; :||</code>, and vectors can be surrounded by either <code>&lt; &hellip;
      &gt;</code> or <code>&lt;: &hellip; :&gt;</code>.  Those with colons are <em>matched pairs</em> and should be used
      whenever there might be a chance of confusion about pairing. Those without colons are <em>context-sensitive</em>
      in that they have multiple meanings and therefore may not be automatically matched by the Lexer. Additionally, if
      an expression opened with one type of delimiter, it must be closed with the same type (i.e.  context-aware vs.
      matched).

    p All delimiters have "infinite" precedence; any and all contents will be grouped together.

    h3#functions Functions
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Trig
          td \( \sin(\theta) \), &hellip;
          td: code sin(theta), &hellip;
          td Also cos, tan, cot, sec, csc
        tr
          td Inverse Trig
          td \( \arcsin(x) \), &hellip;
          td: code arcsin(x), &hellip;
          td Also arccos, arctan, arccot, arcsec, arccsc
        tr
          td Hyperbolic Trig
          td \( \sinh(\lambda) \), &hellip;
          td: code sinh(lambda), &hellip;
          td Also cosh, tanh, coth, sech, csch
        tr
          td Inv. Hyp. Trig
          td \( \mathrm{arcsinh}(x) \), &hellip;
          td: code arcsinh(x), &hellip;
          td Also arccosh, arctanh, arccoth, arcsech, arccsch
        tr
          td Absolute Value
          td \( \left| a \right| \)
          td: code abs(a)
          td May be expressed with "pipe" delimiters.
        tr
          td Floor
          td \( \left\lfloor x \right\rfloor \)
          td: code floor(x)
          td
        tr
          td Ceiling
          td \( \left\lceil x \right\rceil \)
          td: code ceil(x), ceiling(x)
          td
        tr
          td Square Root
          td \( \sqrt{a} \)
          td: code sqrt(a)
          td
        tr
          td \(n\)th Root
          td \( \sqrt[n]{a} \)
          td: code root(a, n)
          td
        tr
          td Natural Exponential
          td \( \exp(a) \)
          td: code exp(a)
          td
        tr
          td Natural Logarithm
          td \( \ln(a) \)
          td: code ln(a)
          td
        tr
          td Logarithm with Base
          td \( \log_b{a} \)
          td: code log(a, b)
          td
        tr
          td Combination
          td \( \binom{n}{r} \)
          td: code C(n,r)
          td Binomial Coefficient, choose
        tr
          td Permutation
          td \( P(n,r) \)
          td: code P(n,r)
          td
        tr
          td Limit
          td \( \displaystyle\lim_{x\to a} f(x) \)
          td: code lim(f(x), a, x), limit(f(x), x, a), &amp;lim &amp;_(x -&gt; a) f(x)
          td <code>&amp;lim</code> notation not implemented
        tr
          td Derivative
          td \( \displaystyle \frac{\mathrm{d}}{\mathrm{d}x} \left( f(x) \right) \)
          td: code diff(f(x), x), &amp;df(x)/&amp;dx
          td
        tr
          td Partial Derivative
          td \( \displaystyle \frac{\partial}{\partial x} \left( f(x,y) \right) \)
          td: code pdiff(f(x,y), x), &amp;pdf(x)/&amp;pdx
          td
        tr
          td Indefinite Integral
          td \( \displaystyle \int f(x) \,\mathrm{d}x \)
          td: code int(f(x),x), &amp;int f(x) &amp;dx
          td
        tr
          td Definite Integral
          td \( \displaystyle \int_a^b f(x) \,\mathrm{d}x \)
          td: code int(f(x),x,a,b), &amp;int &amp;_a &amp;^b f(x) &amp;dx
          td
        tr
          td Sum Over Range
          td \( \displaystyle \sum_{i=m}^n a_i \)
          td: code sum(a&amp;_i,i,m,n), &amp;sum &amp;_(i=m) &amp;^n a&amp;_i
          td <code>&amp;sum</code> notation not implemented
        tr
          td Sum Over Set
          td \( \displaystyle \sum_{i \in S} a_i \)
          td: code sum(a&amp;_i, i in S), &amp;sum &amp;_(i in S) a&amp;_i
          td <code>&amp;sum</code> notation not implemented
        tr
          td Product Over Range
          td \( \displaystyle \prod_{i=m}^n a_i \)
          td: code prod(a&amp;_i,m,n), product(a&amp;_i,m,n), &amp;prod &amp;_(i=m) &amp;^n a&amp;_i
          td <code>&amp;prod</code> notation not implemented
        tr
          td Product Over Set
          td \( \displaystyle \prod_{i \in S} a_i \)
          td: code prod(a&amp;_i, i in S), product(a&amp;_i, i in S), &amp;prod &amp;_(i in S) a&amp;_i
          td <code>&amp;prod</code> notation not implemented
        tr
          td Union Over Range
          td \( \displaystyle \bigcup_{i=m}^n S_i \)
          td: code union(S&amp;_i,m,n), &amp;union &amp;_(i=m) &amp;^n S&amp;_i
          td not implemented
        tr
          td Union Over Set
          td \( \displaystyle \bigcup_{i \in T} S_i \)
          td: code union(S&amp;_i, i in T), &amp;union &amp;_(i in T) S&amp;_i
          td not implemented
        tr
          td Intersection Over Range
          td \( \displaystyle \bigcap_{i=m}^n S_i \)
          td: code intersect(S&amp;_i,m,n), &amp;intersect &amp;_(i=m) &amp;^n S&amp;_i
          td not implemented
        tr
          td Intersection Over Set
          td \( \displaystyle \bigcap_{i \in T} S_i \)
          td: code intersect(S&amp;_i, i in T), &amp;intersect &amp;_(i in T) S&amp;_i
          td not implemented

  section#by-topic
    h2 Symbols by Topic

    p.
      Repetition can lead to discrepancy, and this section is already quite repetetive. Please refer to the tables above
      for precedence and associativity information. These tables are provided merely for convenience when attempting to
      find a particular token. Hence it is redundant to provide extra information.

    h3#arithmetic Arithmetic
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Imaginary Unit
          td \( i \)
          td: code #i
          td \( \sqrt{-1} \)
        tr
          td Plus, Positive
          td \( + \)
          td: code +
          td binary or unary
        tr
          td Minus, Negative
          td \( - \)
          td: code -
          td binary or unary
        tr
          td Plus/Minus
          td \( \pm \)
          td: code +/-, &amp;pm
          td binary or unary
        tr
          td Minus/Plus
          td \( \mp \)
          td: code -/+, &amp;mp
          td binary or unary
        tr
          td Times
          td \( \cdot \)
          td: code *
          td Multiplication
        tr
          td Divided by
          td \( \frac{a}{b} \), \( a/b \)
          td: code a/b, a &amp;/ b
          td Division
        tr
          td Power
          td \( a^b \)
          td: code a^b, a**b
          td Exponentiation
        tr
          td Square Root
          td \( \sqrt{a} \)
          td: code sqrt(a)
          td
        tr
          td \( n \)-th Root
          td \( \sqrt[n]{a} \)
          td: code root(a, n)
          td
        tr
          td Log base n
          td \( \log_n{a} \)
          td: code log(a, n)
          td
        tr
          td Natural Exponential
          td \( \exp(a) \)
          td: code exp(a)
          td
        tr
          td Natural Logarithm
          td \( \ln(a) \)
          td: code ln(a)
          td
        tr
          td Absolute Value
          td \( \left| a \right| \)
          td: code |a|, |:a:|, abs(a)
          td
        tr
          td Factorial
          td \( n! \)
          td: code a!
          td
        tr
          td Ratio
          td \( a:b \)
          td: code a&amp;:b
          td
        tr
          td Ratio Equality
          td \( a:b :: c:d \)
          td: code a&amp;:b :: c&amp;:d, a&amp;:b as c&amp;:d
          td
        tr
          td Equal
          td \( = \)
          td: code
            | =, ==
          td
        tr
          td Not Equal
          td \( \ne \)
          td: code !=, /=, &lt;&gt;
          td
        tr
          td Less Than
          td \( &lt; \)
          td: code &lt;
          td
        tr
          td Greater Than
          td \( &gt; \)
          td: code &gt;
          td
        tr
          td Less Than or Equal
          td \( \le \)
          td: code &lt;=
          td
        tr
          td Greater Than or Equal
          td \( \ge \)
          td: code &gt;=
          td
        tr
          td Parentheses
          td \( \left( \ \right) \)
          td: code ( )
          td

    h3#algebra Algebra
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Natural Numbers
          td \( \mathbb{N} \)
          td: code #N
          td
        tr
          td Integer Ring
          td \( \mathbb{Z} \)
          td: code #Z
          td
        tr
          td Rational Field
          td \( \mathbb{Q} \)
          td: code #Q
          td
        tr
          td Real Field
          td \( \mathbb{R} \)
          td: code #R
          td
        tr
          td Complex Field
          td \( \mathbb{C} \)
          td: code #C
          td
        tr
          td Function Composition
          td \( f \circ g \)
          td: code f @ g
          td
        tr
          td Function Repeated Composition
          td \( f^{\circ n} \)
          td: code f @@ n
          td not implemented
        tr
          td Sum Over Range
          td \( \displaystyle \sum_{i=m}^n a_i \)
          td: code sum(a&amp;_i,i,m,n), &amp;sum &amp;_(i=m) &amp;^n a&amp;_i
          td <code>&amp;sum</code> notation not implemented
        tr
          td Sum Over Set
          td \( \displaystyle \sum_{i \in S} a_i \)
          td: code sum(a&amp;_i, i in S), &amp;sum &amp;_(i in S) a&amp;_i
          td <code>&amp;sum</code> notation not implemented
        tr
          td Product Over Range
          td \( \displaystyle \prod_{i=m}^n a_i \)
          td: code prod(a&amp;_i,m,n), product(a&amp;_i,m,n), &amp;prod &amp;_(i=m) &amp;^n a&amp;_i
          td <code>&amp;prod</code> notation not implemented
        tr
          td Product Over Set
          td \( \displaystyle \prod_{i \in S} a_i \)
          td: code prod(a&amp;_i, i in S), product(a&amp;_i, i in S), &amp;prod &amp;_(i in S) a&amp;_i
          td <code>&amp;prod</code> notation not implemented

    h3#geometry Geometry
    table
      thead
        tr
          td Name
          td Symbol
          td Code
          td Description
      tbody
        tr
          td Pi
          td \( \pi \)
          td: code #pi, #p
          td 3.14&hellip;
        tr
          td Tau
          td \( \tau \)
          td: code #tau, #t
          td \( 2 \pi \) &asymp; 6.28&hellip;
        tr
          td Open Interval
          td \( \left( a,b \right) \)
          td: code (:a,b:)
          td Exclusive Range Delimiters
        tr
          td Closed Interval
          td \( \left[ a,b \right] \)
          td: code [:a,b:]
          td Inclusive Range Delimiters
        tr
          td Half-Open Interval
          td \( \left[ a,b \right) \)
          td: code [:a,b:)
          td Mixed Range Delimiters
        tr
          td Congruent
          td \( \cong \)
          td: code ~=, congruent
          td
        tr
          td Similar
          td \( \sim \)
          td: code ~, sim, similar
          td
        tr
          td Parallel
          td \( \parallel \)
          td: code para, parallel
          td
        tr
          td Perpendicular
          td \( \perp \)
          td: code perp, perpendicular
          td
        tr
          td Vector Components
          td \( \left\langle a, b, c \right\rangle \)
          td: code &lt; a, b, c &gt;, &lt;: a, b, c :&gt;
          td
        tr
          td Vector
          td \( \vec{a} \)
          td: code &amp;v a
          td
        tr
          td Unit Vector
          td \( \hat{a} \)
          td: code &amp;u a
          td
        tr
          td(rowspan=2) Vector Length
          td \( \left| \vec{a} \right| \)
          td: code | &amp;v a |, |: &amp;v a :|
          td
        tr
          td \( \left\| \vec{a} \right\| \)
          td: code || &amp;v a ||, ||: &amp;v a :||
          td
        tr
          td Zero Vector
          td \( \vec{0} \)
          td: code #v0
          td
        tr
          td \( x \) Unit Vector
          td \( \hat{\imath} \)
          td: code #ui, #vi
          td
        tr
          td \( y \) Unit Vector
          td \( \hat{\jmath} \)
          td: code #uj, #vj
          td
        tr
          td \( z \) Unit Vector
          td \( \hat{k} \)
          td: code #uk, #vk
          td
        tr
          td Dot Product
          td \( \vec{a} \cdot \vec{b} \)
          td: code &amp;v a &amp;. &amp;v b
          td
        tr
          td Cross Product
          td \( \vec{a} \times \vec{b} \)
          td: code &amp;v a &amp;x &amp;v b
          td

    h3#trigonometry Trigonometry
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Trig
          td \( \sin(\theta) \), &hellip;
          td: code sin(theta), &hellip;
          td Also cos, tan, cot, sec, csc
        tr
          td Inverse Trig
          td \( \arcsin(x) \), &hellip;
          td: code arcsin(x), &hellip;
          td Also arccos, arctan, arccot, arcsec, arccsc
        tr
          td Hyperbolic Trig
          td \( \sinh(\lambda) \), &hellip;
          td: code sinh(lambda), &hellip;
          td Also cosh, tanh, coth, sech, csch
        tr
          td Inv. Hyp. Trig
          td \( \mathrm{arcsinh}(x) \), &hellip;
          td: code arcsinh(x), &hellip;
          td Also arccosh, arctanh, arccoth, arcsech, arccsch

    h3#discrete Discrete
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Natural Numbers
          td \( \mathbb{N} \)
          td: code #N
          td
        tr
          td Integer Ring
          td \( \mathbb{Z} \)
          td: code #Z
          td
        tr
          td Factorial
          td \( n! \)
          td: code a!
          td
        tr
          td Floor
          td \( \left\lfloor x \right\rfloor \)
          td: code floor(x)
        tr
          td Ceiling
          td \( \left\lceil x \right\rceil \)
          td: code ceil(x), ceiling(x)
          td
        tr
          td Modulus
          td \( a \pmod{n} \)
          td: code a%n, a mod n
          td
        tr
          td Divides
          td \( p \mid q \)
          td: code p|q, p divides q
          td
        tr
          td Not Divides
          td \( p \nmid q \)
          td: code p~|q, p/|q, p ndivides q, p ndivide q, p notdivides q, p notdivide q
          td
        tr
          td Combination
          td \( \binom{n}{r} \)
          td: code C(n,r)
          td Binomial Coefficient; Choose
        tr
          td Permutation
          td \( P(n,r) \)
          td: code P(n,r)
          td
        tr
          td Sum Over Range
          td \( \displaystyle \sum_{i=m}^n a_i \)
          td: code sum(a&amp;_i,i,m,n), &amp;sum &amp;_(i=m) &amp;^n a&amp;_i
          td <code>&amp;sum</code> notation not implemented
        tr
          td Sum Over Set
          td \( \displaystyle \sum_{i \in S} a_i \)
          td: code sum(a&amp;_i, i in S), &amp;sum &amp;_(i in S) a&amp;_i
          td <code>&amp;sum</code> notation not implemented
        tr
          td Product Over Range
          td \( \displaystyle \prod_{i=m}^n a_i \)
          td: code prod(a&amp;_i,m,n), product(a&amp;_i,m,n), &amp;prod &amp;_(i=m) &amp;^n a&amp;_i
          td <code>&amp;prod</code> notation not implemented
        tr
          td Product Over Set
          td \( \displaystyle \prod_{i \in S} a_i \)
          td: code prod(a&amp;_i, i in S), product(a&amp;_i, i in S), &amp;prod &amp;_(i in S) a&amp;_i
          td <code>&amp;prod</code> notation not implemented
        tr
          td Union Over Range
          td \( \displaystyle \bigcup_{i=m}^n S_i \)
          td: code union(S&amp;_i,m,n), &amp;union &amp;_(i=m) &amp;^n S&amp;_i
          td not implemented
        tr
          td Union Over Set
          td \( \displaystyle \bigcup_{i \in T} S_i \)
          td: code union(S&amp;_i, i in T), &amp;union &amp;_(i in T) S&amp;_i
          td not implemented
        tr
          td Intersection Over Range
          td \( \displaystyle \bigcap_{i=m}^n S_i \)
          td: code intersect(S&amp;_i,m,n), &amp;intersect &amp;_(i=m) &amp;^n S&amp;_i
          td not implemented
        tr
          td Intersection Over Set
          td \( \displaystyle \bigcap_{i \in T} S_i \)
          td: code intersect(S&amp;_i, i in T), &amp;intersect &amp;_(i in T) S&amp;_i
          td not implemented

    h3#calculus Calculus
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Pi
          td \( \pi \)
          td: code #pi, #p
          td 3.14&hellip;
        tr
          td Tau
          td \( \tau \)
          td: code #tau, #t
          td \( 2 \pi \) &asymp; 6.28&hellip;
        tr
          td E
          td \( \mathrm{e} \)
          td: code #e
          td 2.718&hellip;, Natural Base, Euler-Napier number
        tr
          td gamma
          td \( \gamma \)
          td: code #gamma
          td 0.577&hellip;, Euler-Mascheroni constant
        tr
          td infinity
          td \( \infty \)
          td: code #infinity, infinity
          td \( \infty \) &asymp; <span class="error">#!ERROR: memory overflow</span>
        tr
          td Limit
          td \( \displaystyle\lim_{x\to a} f(x) \)
          td: code lim(f(x), a, x), limit(f(x), x, a), &amp;lim &amp;_(x -&gt; a) f(x)
          td <code>&amp;lim</code> notation not implemented
        tr
          td Derivative
          td \( \displaystyle \frac{\mathrm{d}}{\mathrm{d}x} \left( f(x) \right) \)
          td: code diff(f(x), x), &amp;df(x)/&amp;dx
          td
        tr
          td Partial Derivative
          td \( \displaystyle \frac{\partial}{\partial x} \left( f(x,y) \right) \)
          td: code pdiff(f(x,y), x), &amp;pdf(x)/&amp;pdx
          td
        tr
          td Prime derivative
          td \( f' \)
          td: code f'
          td Derivative w.r.t. \( x \) or first or only variable
        tr
          td Dot derivative
          td \( \dot{f} \)
          td: code f.
          td Derivative w.r.t. \( t \) or second variable
        tr
          td Change
          td \( \Delta x \)
          td: code &amp;D x
          td Coordinate Difference
        tr
          td Differential
          td \( \mathrm{d} x \)
          td: code &amp;d x
          td
        tr
          td Partial Differential
          td \( \partial x \)
          td: code &amp;pd x
          td
        tr
          td Riemann Sum
          td \( \displaystyle \sum_{i=1}^n f(x_i) \, \Delta x_i \)
          td: code sum(f(x&amp;_i)*&amp;Dx&amp;_i, i, 1, n), &amp;sum &amp;_(i=1) &amp;^n F(x&amp;_i)*&amp;Dx&amp;_i
          td <code>&amp;sum</code> notation not implemented
        tr
          td Indefinite Integral
          td \( \displaystyle \int f(x) \,\mathrm{d}x \)
          td: code int(f(x),x), &amp;int f(x) &amp;dx
          td
        tr
          td Definite Integral
          td \( \displaystyle \int_a^b f(x) \,\mathrm{d}x \)
          td: code int(f(x),x,a,b), &amp;int &amp;_a &amp;^b f(x) &amp;dx
          td
        tr
          td Infinite Series
          td \( \displaystyle \sum_{i=1}^\infty a_i \)
          td: code sum(a&amp;_i, i, 1, infinity), &amp;sum &amp;_(i=1) &amp;^infinity a&amp;_i
          td <code>&amp;sum</code> notation not implemented
        tr
          td Gradient
          td \( \vec{\nabla} f \), \( \mathrm{grad}(f) \)
          td: code &amp;del f, grad(f)
          td
        tr
          td Divergence
          td \( \vec{\nabla} \cdot F \), \( \mathrm{div}(F) \)
          td: code &amp;del. F, div(F)
          td
        tr
          td Curl
          td \( \vec{\nabla} \times F \), \( \mathrm{curl}(F) \)
          td: code &amp;delx F, curl(F)
          td

    h3#set-theory Set Theory
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Set Delimiters
          td \( \left\{ \ \right\} \)
          td: code { }
          td
        tr
          td Such That
          td \( p : q \)
          td: code p:q
          td Used with set builder and quantifiers
        tr
          td Universal Set
          td \( \mathbb{U} \)
          td: code #U
          td
        tr
          td Empty Set
          td \( \emptyset \)
          td: code #empty, {}
          td
        tr
          td Natural Numbers
          td \( \mathbb{N} \)
          td: code #N
          td
        tr
          td Integer Ring
          td \( \mathbb{Z} \)
          td: code #Z
          td
        tr
          td Rational Field
          td \( \mathbb{Q} \)
          td: code #Q
          td
        tr
          td Real Field
          td \( \mathbb{R} \)
          td: code #R
          td
        tr
          td Complex Field
          td \( \mathbb{C} \)
          td: code #C
          td
        tr
          td Quaternion Ring
          td \( \mathbb{H} \)
          td: code #H
          td Hamilton numbers
        tr
          td Octonian Algebra
          td \( \mathbb{O} \)
          td: code #O
          td Cayley numbers, Type "Oh"
        tr
          td Subset
          td \( A \subseteq B \)
          td: code A subset B
          td
        tr
          td Superset
          td \( A \supseteq B \)
          td: code A superset B, A supset B
          td
        tr
          td Proper Subset
          td \( A \subset B \)
          td: code A propersubset B, A propsubset B, A psubset B
          td
        tr
          td Proper Superset
          td \( A \supset B \)
          td: code A propersuperset B, A propsuperset B, A psuperset B, A propersupset B, A propsupset B, A psupset B
          td
        tr
          td Inclusion
          td \( a \in A \)
          td: code a in A
          td
        tr
          td Union
          td \( a \cup b \)
          td: code a union b
          td
        tr
          td Intersection
          td \( a \cap b \)
          td: code a intersect b
          td
        tr
          td Set Difference
          td \( a \setminus b \)
          td: code a \ b, a minus b
          td
        tr
          td Cartesian Product
          td \( A \times B \)
          td: code A &amp;* B, A &amp;x B
          td
          td.center 16
          td.center Left
        tr
          td Direct Sum
          td \( A \oplus B \)
          td: code A &amp;o+ B
          td
          td.center 11
          td.center Left
        tr
          td Union Over Range
          td \( \displaystyle \bigcup_{i=m}^n S_i \)
          td: code union(S&amp;_i,m,n), &amp;union &amp;_(i=m) &amp;^n S&amp;_i
          td not implemented
        tr
          td Union Over Set
          td \( \displaystyle \bigcup_{i \in T} S_i \)
          td: code union(S&amp;_i, i in T), &amp;union &amp;_(i in T) S&amp;_i
          td not implemented
        tr
          td Intersection Over Range
          td \( \displaystyle \bigcap_{i=m}^n S_i \)
          td: code intersect(S&amp;_i,m,n), &amp;intersect &amp;_(i=m) &amp;^n S&amp;_i
          td not implemented
        tr
          td Intersection Over Set
          td \( \displaystyle \bigcap_{i \in T} S_i \)
          td: code intersect(S&amp;_i, i in T), &amp;intersect &amp;_(i in T) S&amp;_i
          td not implemented

    h3#logic Logic
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td True
          td \( \mathbf{T} \)
          td: code #T, #true, true
          td
        tr
          td False
          td \( \mathbf{F} \)
          td: code #F, #false, false
          td
        tr
          td And
          td \( p \wedge q \)
          td: code p &amp;&amp; q, p and q
          td Conjugation
        tr
          td Or
          td \( p \vee q \)
          td: code p || q, p or q
          td Disjunction
        tr
          td Exclusive Or
          td \( p \veebar q \)
          td: code p xor q
          td Exclusion
        tr
          td Implies
          td \( p \rightarrow q \)
          td: code p -&gt; q, p implies q, p onlyif q, if p then q
          td Conditional
        tr
          td Implied By
          td \( p \leftarrow q \)
          td: code p &lt;- q, p imqliedby q, p if q, p when q, p whenever q
          td Reverse Conditional
        tr
          td If And Only If
          td \( p \leftrightarrow q \)
          td: code p &lt;-&gt; q, p iff q
          td Biconditional
        tr
          td Equivalent
          td \( \equiv \)
          td: code
            | ===, equiv
          td
        tr
          td Not Equivalent
          td \( \not\equiv \)
          td: code !==, /==, nequiv
          td
        tr
          td(rowspan=2) Universal Quantifier
          td \( \forall x \) (we have) \( P(x) \)
          td: code forall x -> P(x)
          td(rowspan=2) "For all &hellip;"
        tr
          td \( \forall x :~Q(x) \) (we have) \( P(x) \)
          td: code forall x : Q(x) -&gt; P(x)
        tr
          td Existential Quantifier
          td \( \exists x :~Q(x) \)
          td: code exists x : Q(x)
          td "There exists &hellip; such that &hellip;"
        tr
          td Unique Quantifier
          td \( \exists ! x :~Q(x) \)
          td: code unique x : Q(x)
          td "There exists a unique &hellip; such that &hellip;"

    h3#linear-algebra Linear Algebra
    table
      thead
        tr
          th Name
          th Symbol
          th Code
          th Description
      tbody
        tr
          td Vector Delimiters
          td \( \left\langle \ \right\rangle \)
          td: code &lt; &gt;, &lt;: :&gt;
          td
        tr
          td Zero Vector
          td \( \vec{0} \)
          td: code #v0
          td
        tr
          td \( x \) Unit Vector
          td \( \hat{\imath} \)
          td: code #ui, #vi
          td
        tr
          td \( y \) Unit Vector
          td \( \hat{\jmath} \)
          td: code #uj, #vj
          td
        tr
          td \( z \) Unit Vector
          td \( \hat{k} \)
          td: code #uk, #vk
          td
        tr
          td(rowspan=2) Matrix Delimiters
          td \( \left[ \left\langle \ \right\rangle, \left\langle \ \right\rangle \right] \)
          td: code [ < >, < > ]
          td Row of Columns
        tr
          td \( \left\langle \left[ \ \right], \left[ \ \right] \right\rangle \)
          td: code < [ ], [ ] >
          td Column of Rows
        tr
          td Zero Matrix
          td \( \mathbf{0} \)
          td: code #0
          td Type "zero"
        tr
          td Unit Matrix
          td \( \mathbf{I} \)
          td: code #1
          td Identity Matrix, Type "one"

block javascripts
    script(src='http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML')

